# 구조적 프로그래밍 요소

- 모든 프로그래밍 언어는 구조적 프로그래밍 요소를 포함한다.
  - 함수 호출
  - 조건문, 반복문 사용
  - 명령어를 위에서 아래로 순서대로 실행
- 구조적 프로그래밍은 기계가 이해하는 방식


## 타입
- String
  - 연속된 문자를 표현하는 클래스형
    - new를 이용해서 개체 생성도 가능하다
  - 클래스는 언제나 참조형
  - String 클래스의 구성
    - 연속된 문자를 저장하는 메모리
  - immutable
    - 변경이 불가능하다
    - 바꾸고 싶다면 새 문자열을 만들어야 한다.
  - AString.equals(BString) = boolean
    - 문자열 비교는 이 함수를 사용하자
    - == 쓰지 말것 => 주소참조의 비교일 뿐
  
## 리터럴
  - int의 리터럴: 없ㅇ므
  - long의 리터럴: L 혹은 l
    - 생략가능하지만 int의 범위보다 큰 수일 때 생략하면 컴파일 오류가난다.
  - float: F 혹은 f

## 문자, 문자열
  - "" 문자열
  - '' 문자
  - 이스케이프 문자: \로 시작

## final 키워드
- java에서는 const 대신 final 키워드를 사용한다.
- 변수 값 변경을 금지
- 지역변수
- 클래스 멤버 변수
- 메서드 매개변수
- 클래스와 메서드

## 주석
- // 한 줄 주석
- /* */ 여러 줄 주석
- javadoc 주석
  - /**
  - * 함수 주석 <설명>
  - * @param, @return
  - * @<태그> <태그>에 대한 설명
  - **/
  - Java API 문서를 생성한다.

## enum
- 열거형은 독자적 또는 클래스 내부에 선언할 수 있음
- 각 원소에 원하는 값을 대입하지 못함
- new를 사용하지 않는다

## var
- java 10부터 지원
- 컴파일러가 알아서 자료형을 추론해줌 (type inference)
- 선언과 동시에 값을 대입해야 함
- 값을 선언하지 않으면 컴파일 오류가 남
- 선언과 동시에 {}를 이용해 값을 대입할 수 없음

## 람다 표현식
- (매개변수) => 표현식 몸통
- (매개변수) => { 표현식 몸통 }
- 이름 없는 함수로 내포(nested) 함수라고도 부름


## 모듈
- 기본방식: 패키지
- 기존 패키지 시스템의 한계
  - 애플리케이션이 사용하는 클래스 목록을 찾는 공식적인 방법이 없음
    - 누락된 클래스가 있다면 실행 중에 그것을 사용하려 할 때 오류 발생
    - 사용중인 패키지에 있는 모든 클래스를 같이 배포하는 게 일반적
      - Java 자체 제공 라이브러리의 크기가 커짐
      - 사용하지 않는 클래스까지 같이 배포할 경우 쓸데없이 용량이 커짐
  - 패키지 안에 모든 public 클래스를 아무나 사용할 수 있음
  - 때로는 그 중 일부만 외부에 노출하고 싶은데 그럴 수 없음
- Java 9부터 지원
- 패키지보다 상위 개념
  - 패키지를 내포함
- 장점
  - 정말 필요한 패키지만 포함할 수 있음 (경량화)
  - 프로그램 시작 시 누락된 모듈을 확인 가능
  - 어떤 모듈이 사용하는 다른 모듈 목록을 찾기 쉬움
  - 모듈 사용자에게 공개할 클래스를 특정할 수 있음
- module-info.java => 패키지별로 만들기
  - 중복을 피해야 한다.
  - 단어별로 폴더를 만들지 않는다.
  - 각 모듈 간의 의존관계를 정의한 파일
  - 컴파일 과정에서 .class 파일로 바뀜
  - 모든 모듈에 반드시 존재해야 함
  - 이 파일 안에 들어가는 내용
    - 본 모듈 안에서 사용하는 외부 모듈 목록
    - 본 모듈 사용자에게 공개할 패키지 목록
- 모듈은 좀 더 효율적으로 패키지를 관리 및 배포하는 방법이다