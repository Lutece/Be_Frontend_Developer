# 알고리즘의 정의

## 컴퓨터 공학에서의 알고리즘 정의
- 어떤 부류의 문제를 해결하는 컴퓨터로 구현 가능한 명백한 명령어들
- 우리가 작성하는 거의 모든 코드는 알고리즘이다.

## 훌륭한 알고리즘이 갖춰야 할 자질
- 입력과 출력이 명확히 정의되어 있어야 함
  - 입력은 시작 시 비어있을 수도 있음
- 알고리즘의 각 단계가 명확하며 모호하지 않아야 함
- 유한 식나 안에 결과(출력)가 나와야 함
- 포팅이 가능한 의사코드 작성하기 (포팅이 어려운 컴퓨터 코드를 포함하면 안됨)
  - 거의 모든 언어에 공통되는 연산만 사용하기 (특정 언어에만 있는 기능은 피하기)
  - 결국 하드웨어와 기계어/어셈블리어 수준에서 지원하는 것들
  - 고수준 언어 중에는 C에서 지원하는 것 정도 (단, 포인터 연산은 제외)
- 같은 문제를 푸는 다양한 방법 중에 가장 효율적임

## 알고리즘 공부를 해도 안 느는 프로그래머들
- 하드웨어가 어떤 연산을 지원하는지 모름
- 이미 존재하는 마법 같은 함수만 호출해봄
  (구현이 어떻게 되어있는 지 생각해보지 않음)
- 컴퓨터에 데이터가 어떻게 저장되는지 모름
- 힙과 스택 메모리의 차이에 대해 모름 등

## 알고리즘의 효율성
- 자원을 효율적 사용을 뜻함
  - 자원
    - 시간: CPU 속도 등
    - 공간/용량: 메모리 사용량 등
- 시간과 공간은 종종 상반 관계
- 자원을 많이 사용할수록 그 알고리즘이 복잡하다고 말함
  - 시간 복잡도
  - 공간 복잡도
  - 알고리즘 복잡도를 표현하는 방법 중 하나: 빅오(Big-O) 표기법
  
```c

public int add1(int num1, int num2) {
  int sum = num1;

  for (int i = 0; i < num2; ++i) {
    ++sum;
  }

  return sum;
};

public int add2(int num1, int num2) {
  return num1 + num2;
};


add1(10, N);
//O(N)

add2(10, N);
//O(1)

```

## 알고리즘의 효율성 분석은 다소 추상적이다.
- 알고리즘 공부를 할 때는 하드웨어 차이에 신경을 안 씀
  - 추상적인 기계에서 알고리즘을 실행한다 가정
  - 알고리즘 자체에 집중하도록 도와줌
- 랜덤 접근 기계(random-access machine, RAM)
  - 다양한 하드웨어를 일반적인 형태로 대표하는 가상의 기계
  - 레지스터를 갖춘 CPU 1개
  - 정수와 부동소수점 저장 가능
  - 메모리 간접 참조(indirection) 지원
  - 캐시 메모리나 가상 메모리 등은 없음

## 주의: 알고리즘의 효율성과 실제 성능
- 실제 코드 실행 속도는 하드웨어 따라 매우 달라질 수 있음
- 따라서 실무에서는 효율성 낮은 알고리즘이 더 빠르기도 함
  - 실무 최적화 기초: 실제 하드웨어에서의 성능 측정
  - 컴퓨터 구조를 공부해야 하는 이유
- 공부법
  - 알고리즘 공부를 통해 이론상의 성능에 대해 확실히 학습할 것
  - 하드웨어에 따라 달라지는 부분은 추가 지식을 늘려나가면 됨
  
## 알고리즘의 올바름 검증
- 알고리즘이 올바로 작동하는지 검증하는 것도 중요한 부분
- 실무는 버그 처리 프로세스를 따름
- 제대로 작동 안 하면 효율성을 논할 가치도 없음