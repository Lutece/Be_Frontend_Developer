<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Be_Software_Engineer</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="dataStructure_and_algorithm/introduction.html"><strong aria-hidden="true">2.</strong> Data Structure and Algorithm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dataStructure_and_algorithm/final/bigO.html"><strong aria-hidden="true">2.1.</strong> BigO</a></li><li class="chapter-item expanded "><a href="dataStructure_and_algorithm/final/array.html"><strong aria-hidden="true">2.2.</strong> 배열</a></li><li class="chapter-item expanded "><a href="dataStructure_and_algorithm/pocu/introduction.html"><strong aria-hidden="true">2.3.</strong> pocu 강의정리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dataStructure_and_algorithm/pocu/algorithm.html"><strong aria-hidden="true">2.3.1.</strong> 알고리즘의 정의와 효율성</a></li><li class="chapter-item expanded "><a href="dataStructure_and_algorithm/pocu/bigO.html"><strong aria-hidden="true">2.3.2.</strong> 빅오표기법</a></li><li class="chapter-item expanded "><a href="dataStructure_and_algorithm/pocu/array.html"><strong aria-hidden="true">2.3.3.</strong> 배열</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="java/introduction.html"><strong aria-hidden="true">3.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/pocu/1.html"><strong aria-hidden="true">3.1.</strong> pocu 강의 정리</a></li><li class="chapter-item expanded "><a href="java/books/1/basic.html"><strong aria-hidden="true">3.2.</strong> 자바의 신</a></li></ol></li><li class="chapter-item expanded "><a href="javascript/introduction.html"><strong aria-hidden="true">4.</strong> Javascript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript/var.html"><strong aria-hidden="true">4.1.</strong> var</a></li><li class="chapter-item expanded "><a href="javascript/data.html"><strong aria-hidden="true">4.2.</strong> data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript/data/array.html"><strong aria-hidden="true">4.2.1.</strong> array</a></li><li class="chapter-item expanded "><a href="javascript/data/collection.html"><strong aria-hidden="true">4.2.2.</strong> collection</a></li><li class="chapter-item expanded "><a href="javascript/data/date.html"><strong aria-hidden="true">4.2.3.</strong> date</a></li><li class="chapter-item expanded "><a href="javascript/data/math.html"><strong aria-hidden="true">4.2.4.</strong> math</a></li><li class="chapter-item expanded "><a href="javascript/data/number.html"><strong aria-hidden="true">4.2.5.</strong> number</a></li><li class="chapter-item expanded "><a href="javascript/data/String.html"><strong aria-hidden="true">4.2.6.</strong> string</a></li><li class="chapter-item expanded "><a href="javascript/data/symbol.html"><strong aria-hidden="true">4.2.7.</strong> symbol</a></li></ol></li><li class="chapter-item expanded "><a href="javascript/hoisting.html"><strong aria-hidden="true">4.3.</strong> hosting</a></li><li class="chapter-item expanded "><a href="javascript/json.html"><strong aria-hidden="true">4.4.</strong> json</a></li><li class="chapter-item expanded "><a href="javascript/scope.html"><strong aria-hidden="true">4.5.</strong> scope</a></li></ol></li><li class="chapter-item expanded "><a href="linux/introduction.html"><strong aria-hidden="true">5.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/books/1/introduction.html"><strong aria-hidden="true">5.1.</strong> 실습과 그림으로 배우는 리눅스 구조</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/books/1/chapter1.html"><strong aria-hidden="true">5.1.1.</strong> 컴퓨터 시스템의 개요</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter2.html"><strong aria-hidden="true">5.1.2.</strong> 사용자 모드로 구현되는 기능</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter3.html"><strong aria-hidden="true">5.1.3.</strong> 프로세스 관리</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter4.html"><strong aria-hidden="true">5.1.4.</strong> 프로세스 스케줄러</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter5.html"><strong aria-hidden="true">5.1.5.</strong> 메모리 관리</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter6.html"><strong aria-hidden="true">5.1.6.</strong> 메모리 계층</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter7.html"><strong aria-hidden="true">5.1.7.</strong> 파일 시스템</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter8.html"><strong aria-hidden="true">5.1.8.</strong> 저장 장치</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Be_Software_Engineer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="프로그래밍에-대해-기록하는-곳입니다"><a class="header" href="#프로그래밍에-대해-기록하는-곳입니다">프로그래밍에 대해 기록하는 곳입니다.</a></h1>
<h2 id="더-나은-개발자가-되기-위해"><a class="header" href="#더-나은-개발자가-되기-위해">더 나은 개발자가 되기 위해...</a></h2>
<ul>
<li><a href="introduction//javascript/introduction.html">Javascript</a></li>
<li><a href="introduction//java/introduction.html">Java</a></li>
<li><a href="introduction//linux/introduction.html">Linux</a></li>
<li><a href="introduction//dataStructure_and_algorithm/introduction.html">Data Structure and Algorithm</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자료구조-및-알고리즘"><a class="header" href="#자료구조-및-알고리즘">자료구조 및 알고리즘</a></h1>
<ul>
<li><a href="dataStructure_and_algorithm/./pocu/introduction.html">POCU 알고리즘</a></li>
</ul>
<h2 id="총-정리"><a class="header" href="#총-정리">총 정리</a></h2>
<ul>
<li><a href="dataStructure_and_algorithm/./final/bigO.html">BigO</a></li>
<li><a href="dataStructure_and_algorithm/./final/array.html">배열</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="점근-표기법과-빅오-표기법"><a class="header" href="#점근-표기법과-빅오-표기법">점근 표기법과 빅오 표기법</a></h1>
<h2 id="점근-표기법-asymptotic-notation"><a class="header" href="#점근-표기법-asymptotic-notation">점근 표기법 (asymptotic notation)</a></h2>
<ul>
<li>정수론과 해석학의 방법</li>
<li>어떤 함수가 증가하는 모습을 다른 함수와 비교</li>
<li>알고리즘의 복잡도를 논하거나 단순화시킬 때 사용</li>
</ul>
<h2 id="빅오-표기법-big-o-notation"><a class="header" href="#빅오-표기법-big-o-notation">빅오 표기법 (Big-O notation)</a></h2>
<ul>
<li>대문자 O를 이용해 표기</li>
<li>주로 알고리즘을 분류하기 위해 사용
<ul>
<li>O(1), O(log n), O(n), O(nlog n), O(n2), O(n!)</li>
</ul>
</li>
<li>O의 의미
<ul>
<li>order of the function (대략 그 함수 정도)</li>
</ul>
</li>
</ul>
<h3 id="어떤-기준으로-분류하나요"><a class="header" href="#어떤-기준으로-분류하나요">어떤 기준으로 분류하나요?</a></h3>
<ul>
<li><strong>입력 데이터가 많아짐</strong>에 따라 다음 둘이 얼마나 늘어나는지 측정
<ul>
<li>실행 시간(시간 복잡도)
<ul>
<li>주로 신경쓰는 부분</li>
<li>입력 데이터가 많아짐에 따라 얼마나 시간이 더 걸리는지</li>
</ul>
</li>
<li>필요한 공간(공간 복잡도)</li>
</ul>
</li>
<li>즉, 입력이 증가함에 따른 시간 및 공간의 증가량을 의미</li>
</ul>
<h3 id="순서-실행-속도가-가장-작은-순부터-큰-순서까지"><a class="header" href="#순서-실행-속도가-가장-작은-순부터-큰-순서까지">순서 (실행 속도가 가장 작은 순부터 큰 순서까지)</a></h3>
<ul>
<li>O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n2) &lt; O(n!)</li>
</ul>
<h3 id="o1-알고리즘-배열-기준"><a class="header" href="#o1-알고리즘-배열-기준">O(1) 알고리즘 (배열 기준)</a></h3>
<ul>
<li>입력 데이터의 크기 N에 상관없이 언제나 일정한 시간이 걸림</li>
<li>두 수의 합</li>
</ul>
<h3 id="on-알고리즘"><a class="header" href="#on-알고리즘">O(n) 알고리즘</a></h3>
<ul>
<li>입력 데이터의 크기 N에 비례하는 시간이 걸림</li>
<li>예) 모든 수의 총합</li>
</ul>
<h3 id="on-제곱-알고리즘"><a class="header" href="#on-제곱-알고리즘">O(n 제곱) 알고리즘</a></h3>
<ul>
<li>입력 데이터 크기 N의 제곱에 비례하는 시간이 걸림</li>
</ul>
<h3 id="olog-n-알고리즘"><a class="header" href="#olog-n-알고리즘">O(log n) 알고리즘</a></h3>
<ul>
<li>O(1)과 O(n)사이 = O(n)보다는 빠르다</li>
<li>점점 평평해진다.</li>
<li>log =&gt; 지수의 반대</li>
</ul>
<h2 id="알고리즘-평가-지표"><a class="header" href="#알고리즘-평가-지표">알고리즘 평가 지표</a></h2>
<ul>
<li>정확성</li>
<li>작업량</li>
<li>메모리 사용량</li>
<li>최적성</li>
<li>효율성
<ul>
<li>시간 복잡도
<ul>
<li>입력 크기의 값에 대해 단위 연산을 몇 번 수행하는지 계산하여, 알고리즘의 수행시간을 평가하는 방법</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://t1.daumcdn.net/cfile/tistory/99BBBF375CF419260A" alt="알고리즘" /></li>
<li><img src="https://static.packt-cdn.com/products/9781789805789/graphics/assets/e82896f2-626c-45f7-9ce7-54b0be484b54.png" alt="정렬 알고리즘" /></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="배열"><a class="header" href="#배열">배열</a></h1>
<ul>
<li>여러 개체(entity) 값을 순차적으로 나열한 선형 자료구조</li>
<li>접근 방법
<ul>
<li>Array[index]를 통해 O(1)로 접근하게 된다</li>
<li>시간 복잡도
<ul>
<li>접근: O(1)</li>
<li>검색: O(N)</li>
<li>삽입: O(N)</li>
<li>삭제: O(N)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="배열의-실체"><a class="header" href="#배열의-실체">배열의 실체</a></h2>
<ul>
<li>자바스크립트 배열은 다른 언어에서 말하는 일반적인 배열이 아닌 Hash 기반의 객체</li>
<li>메모리가 연속적인 밀집 배열(dense array)가 아닌 비 연속적인 희소 배열(sparse array)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pocu-알고리즘-정리"><a class="header" href="#pocu-알고리즘-정리">POCU 알고리즘 정리</a></h1>
<ul>
<li><a href="dataStructure_and_algorithm/pocu/./algorithm.html">알고리즘의 정의와 효율성</a></li>
<li><a href="dataStructure_and_algorithm/pocu/./bigO.html">빅오 표기법</a></li>
<li><a href="dataStructure_and_algorithm/pocu/./array.html">배열</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="알고리즘의-정의"><a class="header" href="#알고리즘의-정의">알고리즘의 정의</a></h1>
<h2 id="컴퓨터-공학에서의-알고리즘-정의"><a class="header" href="#컴퓨터-공학에서의-알고리즘-정의">컴퓨터 공학에서의 알고리즘 정의</a></h2>
<ul>
<li>어떤 부류의 문제를 해결하는 컴퓨터로 구현 가능한 명백한 명령어들</li>
<li>우리가 작성하는 거의 모든 코드는 알고리즘이다.</li>
</ul>
<h2 id="훌륭한-알고리즘이-갖춰야-할-자질"><a class="header" href="#훌륭한-알고리즘이-갖춰야-할-자질">훌륭한 알고리즘이 갖춰야 할 자질</a></h2>
<ul>
<li>입력과 출력이 명확히 정의되어 있어야 함
<ul>
<li>입력은 시작 시 비어있을 수도 있음</li>
<li>선조건에 대해 생각해봐야 함 (매개변수는 항상 양수다?)</li>
</ul>
</li>
<li>알고리즘의 각 단계가 명확하며 모호하지 않아야 함</li>
<li>유한 식나 안에 결과(출력)가 나와야 함</li>
<li>포팅이 가능한 의사코드 작성하기 (포팅이 어려운 컴퓨터 코드를 포함하면 안됨)
<ul>
<li>거의 모든 언어에 공통되는 연산만 사용하기 (특정 언어에만 있는 기능은 피하기)</li>
<li>결국 하드웨어와 기계어/어셈블리어 수준에서 지원하는 것들</li>
<li>고수준 언어 중에는 C에서 지원하는 것 정도 (단, 포인터 연산은 제외)</li>
</ul>
</li>
<li>같은 문제를 푸는 다양한 방법 중에 가장 효율적임</li>
</ul>
<h2 id="알고리즘-공부를-해도-안-느는-프로그래머들"><a class="header" href="#알고리즘-공부를-해도-안-느는-프로그래머들">알고리즘 공부를 해도 안 느는 프로그래머들</a></h2>
<ul>
<li>하드웨어가 어떤 연산을 지원하는지 모름</li>
<li>이미 존재하는 마법 같은 함수만 호출해봄
(구현이 어떻게 되어있는 지 생각해보지 않음)</li>
<li>컴퓨터에 데이터가 어떻게 저장되는지 모름</li>
<li>힙과 스택 메모리의 차이에 대해 모름 등</li>
</ul>
<h2 id="알고리즘의-효율성"><a class="header" href="#알고리즘의-효율성">알고리즘의 효율성</a></h2>
<ul>
<li>자원을 효율적 사용을 뜻함
<ul>
<li>자원
<ul>
<li>시간: CPU 속도 등</li>
<li>공간/용량: 메모리 사용량 등</li>
</ul>
</li>
</ul>
</li>
<li>시간과 공간은 종종 상반 관계</li>
<li>자원을 많이 사용할수록 그 알고리즘이 복잡하다고 말함
<ul>
<li>시간 복잡도</li>
<li>공간 복잡도</li>
<li>알고리즘 복잡도를 표현하는 방법 중 하나: 빅오(Big-O) 표기법</li>
</ul>
</li>
</ul>
<pre><code class="language-c">
public int add1(int num1, int num2) {
  int sum = num1;

  for (int i = 0; i &lt; num2; ++i) {
    ++sum;
  }

  return sum;
};

public int add2(int num1, int num2) {
  return num1 + num2;
};


add1(10, N);
//O(N)

add2(10, N);
//O(1)

</code></pre>
<h2 id="알고리즘의-효율성-분석은-다소-추상적이다"><a class="header" href="#알고리즘의-효율성-분석은-다소-추상적이다">알고리즘의 효율성 분석은 다소 추상적이다.</a></h2>
<ul>
<li>알고리즘 공부를 할 때는 하드웨어 차이에 신경을 안 씀
<ul>
<li>추상적인 기계에서 알고리즘을 실행한다 가정</li>
<li>알고리즘 자체에 집중하도록 도와줌</li>
</ul>
</li>
<li>랜덤 접근 기계(random-access machine, RAM)
<ul>
<li>다양한 하드웨어를 일반적인 형태로 대표하는 가상의 기계</li>
<li>레지스터를 갖춘 CPU 1개</li>
<li>정수와 부동소수점 저장 가능</li>
<li>메모리 간접 참조(indirection) 지원</li>
<li>캐시 메모리나 가상 메모리 등은 없음</li>
</ul>
</li>
</ul>
<h2 id="주의-알고리즘의-효율성과-실제-성능"><a class="header" href="#주의-알고리즘의-효율성과-실제-성능">주의: 알고리즘의 효율성과 실제 성능</a></h2>
<ul>
<li>실제 코드 실행 속도는 하드웨어 따라 매우 달라질 수 있음</li>
<li>따라서 실무에서는 효율성 낮은 알고리즘이 더 빠르기도 함
<ul>
<li>실무 최적화 기초: 실제 하드웨어에서의 성능 측정</li>
<li>컴퓨터 구조를 공부해야 하는 이유</li>
</ul>
</li>
<li>공부법
<ul>
<li>알고리즘 공부를 통해 이론상의 성능에 대해 확실히 학습할 것</li>
<li>하드웨어에 따라 달라지는 부분은 추가 지식을 늘려나가면 됨</li>
</ul>
</li>
</ul>
<h2 id="알고리즘의-올바름-검증"><a class="header" href="#알고리즘의-올바름-검증">알고리즘의 올바름 검증</a></h2>
<ul>
<li>알고리즘이 올바로 작동하는지 검증하는 것도 중요한 부분</li>
<li>실무는 버그 처리 프로세스를 따름</li>
<li>제대로 작동 안 하면 효율성을 논할 가치도 없음</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="점근-표기법과-빅오-표기법-1"><a class="header" href="#점근-표기법과-빅오-표기법-1">점근 표기법과 빅오 표기법</a></h1>
<h2 id="점근-표기법-asymptotic-notation-1"><a class="header" href="#점근-표기법-asymptotic-notation-1">점근 표기법 (asymptotic notation)</a></h2>
<ul>
<li>정수론과 해석학의 방법</li>
<li>어떤 함수가 증가하는 모습을 다른 함수와 비교</li>
<li>알고리즘의 복잡도를 논하거나 단순화시킬 때 사용</li>
</ul>
<h2 id="빅오-표기법-big-o-notation-1"><a class="header" href="#빅오-표기법-big-o-notation-1">빅오 표기법 (Big-O notation)</a></h2>
<ul>
<li>대문자 O를 이용해 표기</li>
<li>주로 알고리즘을 분류하기 위해 사용
<ul>
<li>O(1), O(log n), O(n), O(nlog n), O(n^2), O(n!)</li>
</ul>
</li>
<li>O의 의미
<ul>
<li>order of the function (대략 그 함수 정도)</li>
</ul>
</li>
</ul>
<h3 id="어떤-기준으로-분류하나요-1"><a class="header" href="#어떤-기준으로-분류하나요-1">어떤 기준으로 분류하나요?</a></h3>
<ul>
<li><strong>입력 데이터가 많아짐</strong>에 따라 다음 둘이 얼마나 늘어나는지 측정
<ul>
<li>실행 시간(시간 복잡도)
<ul>
<li>주로 신경쓰는 부분</li>
<li>입력 데이터가 많아짐에 따라 얼마나 시간이 더 걸리는지</li>
</ul>
</li>
<li>필요한 공간(공간 복잡도)</li>
</ul>
</li>
<li>즉, 입력이 증가함에 따른 시간 및 공간의 증가량을 의미</li>
</ul>
<h3 id="순서-실행-속도가-가장-작은-순부터-큰-순서까지-1"><a class="header" href="#순서-실행-속도가-가장-작은-순부터-큰-순서까지-1">순서 (실행 속도가 가장 작은 순부터 큰 순서까지)</a></h3>
<ul>
<li>O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n^2) &lt; O(n!)</li>
</ul>
<h3 id="o1-알고리즘-배열-기준-1"><a class="header" href="#o1-알고리즘-배열-기준-1">O(1) 알고리즘 (배열 기준)</a></h3>
<ul>
<li>입력 데이터의 크기 N에 상관없이 언제나 일정한 시간이 걸림</li>
<li>두 수의 합</li>
</ul>
<h3 id="on-알고리즘-1"><a class="header" href="#on-알고리즘-1">O(n) 알고리즘</a></h3>
<ul>
<li>입력 데이터의 크기 N에 비례하는 시간이 걸림</li>
<li>예) 모든 수의 총합</li>
</ul>
<h3 id="on-제곱-알고리즘-1"><a class="header" href="#on-제곱-알고리즘-1">O(n 제곱) 알고리즘</a></h3>
<ul>
<li>입력 데이터 크기 N의 제곱에 비례하는 시간이 걸림</li>
</ul>
<h3 id="olog-n-알고리즘-1"><a class="header" href="#olog-n-알고리즘-1">O(log n) 알고리즘</a></h3>
<ul>
<li>O(1)과 O(n)사이 = O(n)보다는 빠르다</li>
<li>점점 평평해진다.</li>
<li>log =&gt; 지수의 반대</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="배열-1"><a class="header" href="#배열-1">배열</a></h1>
<ul>
<li>검색, 삽입, 삭제
<ul>
<li>O(n)</li>
<li>배열의 크기가 변하면 요소의 순서가 변하는 것을 대응하기 위해 하는 일</li>
<li>빈 공간을 메우는 일</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자바"><a class="header" href="#자바">자바</a></h1>
<ul>
<li><a href="java/./pocu/1.html">POCU</a></li>
<li><a href="java/./books/1/basic.html">자바의 신</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="개체지향-프로그래밍oop와-개체지향-분석-및-설계-ooad"><a class="header" href="#개체지향-프로그래밍oop와-개체지향-분석-및-설계-ooad">개체지향 프로그래밍(OOP)와 개체지향 분석 및 설계 (OOAD)</a></h1>
<p>개체지향 프로그래밍은 객관성이 떨어지는 부분들이 있다.</p>
<p>그래서 주관적인 관점으로 바라보게되는 경우가 많다.</p>
<h2 id="정리할-내용들"><a class="header" href="#정리할-내용들">정리할 내용들</a></h2>
<ul>
<li>Java 언어 문법</li>
<li>개체지향 프로그래밍 특성</li>
<li>올바른 개체지향 설계법</li>
<li>개체지향에 대한 다양한 의견들</li>
</ul>
<h3 id="다수설소수설을-알아야-하는-이유"><a class="header" href="#다수설소수설을-알아야-하는-이유">다수설/소수설을 알아야 하는 이유</a></h3>
<p>Java</p>
<ul>
<li>현업에 있는 개발자들이 만들어간 언어</li>
</ul>
<p>개체지향(OO)은 업계에 제대로 몸담지 않은 사람들도 다양한 의견을 내던 분야이다. 
그 이전에 기계어와 성격이 가까운 언어들은 코드가 해석되는 방식이 어느정도 정해져있기 때문에 OO처럼 다양한 의견이 나오기 쉽지 않았다.</p>
<h3 id="좋은-프로그래밍-언어란"><a class="header" href="#좋은-프로그래밍-언어란">좋은 프로그래밍 언어란?</a></h3>
<ul>
<li>프로그래머의 효율을 높이는 언어</li>
<li>프로그래머의 실수를 줄이는 언어</li>
</ul>
<h2 id="java-라는-도구란"><a class="header" href="#java-라는-도구란">Java 라는 도구란?</a></h2>
<ul>
<li>1991년 첫 등장</li>
<li>썬 마이크로시스템즈의 제임스 고슬링과 동료들이 개발함</li>
</ul>
<h3 id="java의-개발-배경"><a class="header" href="#java의-개발-배경">Java의 개발 배경</a></h3>
<ul>
<li>기존 언어는 각 플랫폼마다 컴파일을 해야 했음 그래서
한 번만 빌드하면 어떤 플랫폼에서든 작동하는 언어를 만들게 됨</li>
<li>갑자기 고속 성장하던 인터넷에 맞춰 그쪽으로 방향을 바꾸어 대중화에 성공함</li>
</ul>
<h3 id="가장-많이-쓰이는-매니지드-언어"><a class="header" href="#가장-많이-쓰이는-매니지드-언어">가장 많이 쓰이는 매니지드 언어</a></h3>
<ul>
<li>매니지드 언어이기에 메모리 관리를 덜 신경 써도 됨</li>
<li>기계와 아주 가깝지 않은 개념을 코드로 옮기기에 사용하기 적합</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자바의-신-1권"><a class="header" href="#자바의-신-1권">자바의 신 1권</a></h1>
<p>클래스 내의 변수</p>
<ul>
<li>인스턴스 변수</li>
<li>클래스 변수</li>
<li>지역 변수</li>
<li>매개 변수</li>
</ul>
<h2 id="기본-생성자"><a class="header" href="#기본-생성자">기본 생성자</a></h2>
<p>자바는 생성자를 만들지 않아도 자동으로 만들어지는 기본 생성자가 있다.
생성자는 메소드와 비슷하게 생겼지만, 리턴 타입이 없고, 클래스 이름으로 되어 있다는 점이 메소드와 다르다.</p>
<p>자바에서 생성자는 왜 필요할까?
자바의 생성자는 자바 클래스의 객체(또는 인스턴스)를 생성하기 위해 존재한다.
선언부에 리턴 타입이 없고, 메소드 이름 대신 클래스 이름과 동일하게 이름을 지정하는 것 뿐이다.
생성자에 리턴 타입이 없는 이유는 생성자의 리턴 타입은 클래스의 객체이기 때문이며,
클래스와 이름이 동일해야 컴파일러가 생성자임을 알아차릴 수 있기 때문이다.
생성자는 클래스의 가장 윗부분에 선언하는 것이 좋다.</p>
<p>또 자바는 여러 생성자를 갖을 수 있다.</p>
<p>클래스 선언 권고 순서</p>
<ul>
<li>인스턴스 변수</li>
<li>생성자 영역</li>
<li>메서드 영역</li>
</ul>
<h3 id="dto-data-transfer-object"><a class="header" href="#dto-data-transfer-object">DTO (Data Transfer Object)</a></h3>
<ul>
<li>어떤 속성을 갖는 클래스를 만들고 그 속성들을 쉽게 전달하기 위해서 만드는 패턴이다.</li>
<li>데이터를 다른 서버로 전달하기 위한 것이 주 목적이기도 하다. 어떻게 보면 DTO가 VO를 ㅗ함한다고 볼 수 있다.</li>
</ul>
<h3 id="vo-value-object"><a class="header" href="#vo-value-object">VO (Value Object)</a></h3>
<ul>
<li>데이터를 담아두기 위한 목적으로 사용되는 패턴이다.</li>
</ul>
<h3 id="this"><a class="header" href="#this">this</a></h3>
<ul>
<li>객체 멤버변수와 매개변수를 비교하기 위해 사용되는 키워드</li>
</ul>
<h3 id="메서드-오버라이딩"><a class="header" href="#메서드-오버라이딩">메서드 오버라이딩</a></h3>
<ul>
<li>메서드 이름은 같지만 매개변수를 다르게 하여 중복해서 메서드를 정의할 수 있다.</li>
</ul>
<h3 id="static"><a class="header" href="#static">static</a></h3>
<ul>
<li>객체를 생성하지 않아도 클래스의 메서드를 호출할 수 있게 해주는 키워드</li>
<li>변수를 접근하기 위해서는 static 키워드가 사용되어 선언된 변수가 필요하다</li>
</ul>
<h3 id="static-블록"><a class="header" href="#static-블록">static 블록</a></h3>
<ul>
<li>클래스의 객체가 생성되면서 딱 한번만 불러와야 하는 코드를 정의할 때 사용된다</li>
<li>객체가 생성되기 전에 딱 한번만 호출된다.</li>
<li>클래스 내에 선언되어야 하며, 메서드 내에서는 선언할 수 없다.</li>
<li>static 블록은 여러 개를 선언할 수 있다.</li>
</ul>
<h3 id="다형성-polymorphism"><a class="header" href="#다형성-polymorphism">다형성 (Polymorphism)</a></h3>
<h3 id="상속"><a class="header" href="#상속">상속</a></h3>
<ul>
<li>자식 클래스의 생성자가 호출되면 자동으로 부모 클래스의 매개 변수가 없는 기본 생성자가 호출된다. 명시적으로 super()라고 지정할 수도 있다.</li>
<li>부모 클래스의 생성자를 명시적으로 호출하려면 super()를 사용하면 된다.</li>
<li>부모 클래스에 private로 선언된 변수를 제외한 모든 변수가 자신의 클래스에 선언된 것처럼 사용할 수 있다.</li>
<li>부모 클래스에 선언된 변수와 동일한 이름을 가지는 변수를 선언할 수도 있다. 하지만, 이렇게 엎어 쓰는 것은 권장하지 않는다.</li>
<li>부모 클래스에 선언되어 있지 않는 이름의 변수를 선언할 수 있다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자바스크립트란"><a class="header" href="#자바스크립트란">자바스크립트란?</a></h1>
<ul>
<li>객체(Object) 기반의 스크립트 프로그래밍 언어
<ul>
<li>인터프리터 형식의 언어 (vs 컴파일 언어)</li>
</ul>
</li>
<li>ECMAScript 사양을 준수하는 범용 프로그래밍 언어</li>
<li>웹의 동적 동작을 구현하기 위해 제작된 언어</li>
<li>Mocha -&gt; LiveScript -&gt; Javascript로 명칭이 변경됨</li>
<li>JS 엔진위에서 수행되며, Google V8, Firefox SpiderMonkey, Edge Chakra 가 존재한다.</li>
</ul>
<h2 id="ecmascript란"><a class="header" href="#ecmascript란">ECMAScript란?</a></h2>
<ul>
<li>Ecma International ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어</li>
<li>자바스크립트를 표준화하기 위해 만들어졌으며, 액션스크립트와 J스크립트 등 다른 구현체도 포함</li>
<li>Ecma International: 정보 통신에 대한 표준을 제정하는 비영리 표준화 기구</li>
<li>ECMA-262: Ecma International에서 제정한 기술 규격의 이름으로, 범용 목적의 스크립트 언어 명세 기술</li>
<li>97년 ES1 초판, 09년 ES5, 15년 ES2015(ES6)으로 매해 6월에 버전을 갱신중이다.
<ul>
<li>15년부터 년도가 뒤에 붙는 방식으로 이름이 바뀜</li>
</ul>
</li>
</ul>
<h2 id="자바스크립트-변환-절차"><a class="header" href="#자바스크립트-변환-절차">자바스크립트 변환 절차</a></h2>
<ol>
<li>소스코드를 Parsing</li>
<li>Abstract Syntax Tree</li>
<li>lgnition Bytecode (complied code)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="변수와-상수"><a class="header" href="#변수와-상수">변수와 상수</a></h1>
<h2 id="변수"><a class="header" href="#변수">변수</a></h2>
<ul>
<li>변경 가능한 값을 저장하기 위한 공간 (Memory)</li>
</ul>
<h2 id="상수"><a class="header" href="#상수">상수</a></h2>
<ul>
<li>변경 불가능한 값을 저장하기 위한 공간</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자료형"><a class="header" href="#자료형">자료형</a></h1>
<ul>
<li>Boolean : 논리적 값 (true, false)</li>
<li>null : 존재하지 않거나 유효하지 않은 주소 표시</li>
<li>undefined : 선언 후 값을 할당하지 않은 변수</li>
<li>number : 정수, 실수 등의 숫자</li>
<li>string : 빈 문자열이나 글자들을 표현하는 문자열</li>
<li>symbol : 문자열과 함께 객체 property로 사용, ES6에 추가</li>
<li>object : 두개 이상의 복잡한 개체 저장 가능</li>
</ul>
<h2 id="원시-타입"><a class="header" href="#원시-타입">원시 타입</a></h2>
<ul>
<li>Booelan, null, undefined, number, string, symbol
<ul>
<li>null : null은 값이 비어 있다는 의미로 표현되는 자료형
<ul>
<li>존재하지 않는, 비어있는, 알 수 없는 값을 나타내는 데 사용</li>
</ul>
</li>
<li>undefined : 값이 할당되어 있지 않은 상태를 나타낼 때 사용되는 자료형</li>
<li>number: infinity, -infinity, NaN 같은 특수 숫자 값이 포함되어 있다.</li>
</ul>
</li>
</ul>
<h2 id="객체-타입"><a class="header" href="#객체-타입">객체 타입</a></h2>
<ul>
<li>object : 다수의 원시 자료형을 포함하거나 복잡한 개체를 표현할 수 있는 자료형</li>
</ul>
<h3 id="객체-복사의-문제점"><a class="header" href="#객체-복사의-문제점">객체 복사의 문제점</a></h3>
<ul>
<li>Shallow Copy vs Deep Copy
<ul>
<li>Shallow Copy : Object.assing({}, object), for, spread operator, {...object}</li>
<li>Deep Copy</li>
</ul>
</li>
</ul>
<pre><code class="language-js">Copy Object (그림과 함께 이해하기)

function copyObj(obj) {
  let result = {};

  for(let key in obj) {
    if(typeof obj[key] === &quot;object&quot;) result[key] = copyObj(obj[key]);
    else result[key] = obj[key];
  }

  return result;
}
</code></pre>
<pre><code class="language-js">JSON;

JSON.parse(JSON.stringify(object));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<h2 id="배열의-실체-1"><a class="header" href="#배열의-실체-1">배열의 실체</a></h2>
<ul>
<li>자바스크립트 배열은 다른 언어에서 말하는 일반적인 배열이 아닌 hash 기반의 개체</li>
<li>메모리가 연속적인 밀집 배열(dense array)가 아닌 비 연속적인 희소 배열(sparse array)</li>
<li>배열도 iterable 하다 ( for of, for in 사용가능 )</li>
</ul>
<h3 id="delete"><a class="header" href="#delete">delete</a></h3>
<ul>
<li>delete로 삭제 시 값은 없어지지만 공간은 남게 된다.</li>
</ul>
<h3 id="arraysort"><a class="header" href="#arraysort">Array.sort</a></h3>
<ul>
<li>배열의 원소는 String으로 치환되어 숫자의 비교의 경우 콜백함수를 통해 정렬 기준을 잡아주어야 한다.</li>
</ul>
<h2 id="n차원-array"><a class="header" href="#n차원-array">N차원 Array</a></h2>
<ul>
<li>배열(Array) 안에 N개 만큼의 배열이 존재하는 객체</li>
<li>2/3차원 지도 정보, RGB를 저장하는 2차원 사진 파일 등을 표현할 때 활용 가능</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection"><a class="header" href="#collection">Collection</a></h1>
<ul>
<li>구조 혹은 비구조화 형태로 프로그래밍 언어가 제공하는 값을 담을 수 있는 공간</li>
<li>자바스크립트에서 제공하는 Collection
<ul>
<li>indexed collection
<ul>
<li>array</li>
<li>typed array</li>
</ul>
</li>
<li>keyed collection
<ul>
<li>Object</li>
<li>Map</li>
<li>Set</li>
<li>Weak Map</li>
<li>Weak Set</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<ul>
<li>다양한 자료형의 Key를 허용하고, key-value 형태의 자료형을 저장할 수 있는 Collection</li>
<li>Object와 비교하면 다양한 key의 사용을 허용하고, 값의 추가/삭제 시 메서드를 통해 수행이 필요하다</li>
<li>대표 속성 및 메서드
<ul>
<li>size</li>
<li>set</li>
<li>get</li>
<li>delete</li>
<li>clear</li>
<li>has</li>
<li>keys</li>
<li>values</li>
<li>entires</li>
<li>...</li>
</ul>
</li>
</ul>
<pre><code class="language-js">
let mapList = new Map([
  [key, val],
  [key, val],
  [key, val],
]);

for (let item of mapList.values())
for (let item of mapList.keys())
for (let entity of mapList)

let toObj = Object.fromEntries(mapList);
/* 객체형태로 전환됨 */

let toObj = Object.entries(mapList);
/* 리스트 형태로 전환됨 */

</code></pre>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<ul>
<li>
<p>value만을 저장하며 중복을 허용하지 않는 Collection</p>
</li>
<li>
<p>다양한 자료형을 value로 사용 가능하며, add 호출 시 set이 반환되므로 체이닝(chaining)이 가능하다</p>
</li>
<li>
<p>중복된 데이터를 제거할 때 많이 사용됨</p>
</li>
<li>
<p>대표 속성 및 메서드</p>
<ul>
<li>size</li>
<li>add</li>
<li>delete</li>
<li>clear</li>
<li>has</li>
<li>keys</li>
<li>values</li>
<li>entries</li>
<li>...</li>
</ul>
</li>
<li>
<p>for문을 사용하게 될 경우 value만을 반환한다</p>
<ul>
<li>Map과의 호환성을 위해 entries의 경우 key와 value가 같은 값으로 쌍을 이룬 리스트가 반환된다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="date"><a class="header" href="#date">Date</a></h1>
<ul>
<li>표준 Built-in 객체로써 날짜와 시간을 위한 속성값과 메서드를 제공하는 객체</li>
<li>Date 객체는 1970년 1월 1일 UTC 자정과의 시간 차이를 밀리초로 나타내는 정수 값으로 표현</li>
<li>생성자 및 대표 메서드
<ul>
<li>Date(year, month, date, hours, minutes, seconds, ms)</li>
<li>...</li>
</ul>
</li>
</ul>
<h2 id="benchmark"><a class="header" href="#benchmark">benchmark</a></h2>
<ul>
<li>성능 측정</li>
</ul>
<pre><code class="language-js">
function benchmark(callback_func) {
  let date_1 = new Date(&quot;2020-01-01&quot;);
  let date_2 = new Date();

  let start = Date.now();
  for(let i = 0; i &lt; 100000; i++) {
    callback_func(date_1, date_2);
  }

  return Date.now() - start;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">Math</a></h1>
<ul>
<li>표준 Built-in 객체로써 수학적인 연산을 위한 속성값과 메서드를 제공하는 객체</li>
<li>Math는 생성자 함수가 아니며, 모든 속성과 메서드는 정적이기에 Math.function()으로 언제든 호출 가능
<ul>
<li>Math.E</li>
<li>Math.PI</li>
<li>Math.abs</li>
<li>Math.max</li>
<li>Math.min</li>
<li>Math.random
<ul>
<li>0 ~ 1 사이의 난수 값</li>
</ul>
</li>
<li>Math.pow, Math.sqrt</li>
<li>Math.round, Math.ceil, Math.floor</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-자료형"><a class="header" href="#number-자료형">Number 자료형</a></h1>
<ul>
<li>
<p>자바스크립트에서 일반적인 숫자는 64비트 형식의 IEEE-754 표준 기반 형태로 저장되는 자료형</p>
</li>
<li>
<p>10진수 외에도 16진수,2진수,8진수의 다양한 진수 사용</p>
</li>
<li>
<p>특정 상수 값들을 제공한다</p>
<ul>
<li>MIN_VALUE</li>
<li>MAX_VALUE...</li>
</ul>
</li>
<li>
<p>특정 메서드들을 제공한다.</p>
<ul>
<li>toString()</li>
<li>toFixed()...</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<ul>
<li>UTF-16 형식을 따른다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="심볼"><a class="header" href="#심볼">심볼</a></h1>
<p><strong>Symbol</strong></p>
<ul>
<li>심볼은 ES2015에서 도입된 원시타입입니다.</li>
<li>데이터의 유일함을 나타낼 때 사용됩니다.</li>
<li>심볼은 다른 원시타입과는 달리 Symbol() 함수를 호출해 생성한다.
<ul>
<li>심볼은 원시타입이기 때문에 new 키워드를 사용하지 않는다.</li>
</ul>
</li>
<li>심볼은 비공개 객체 멤버를 만들기 위한 한 가지 방법으로 출발했다.</li>
<li>심볼 참조 없이 접근할 수 없는 열거 불가능 프로퍼티를 만드는데 사용된다.</li>
<li>외부 개발자로부터 보호할 필요가 있는 기능에 적합하다</li>
<li>접근을 제한하는 방식을 제공한다.
<ul>
<li>기존의 방식은 프로퍼티의 문자열에 의존한다.</li>
<li>심볼로 멤버를 만들면 멤버를 만든 심볼로만 그 멤버를 접근할 수 있다.</li>
</ul>
</li>
<li>기존 객체 동작 알고리즘을 확장할 수 있다.
<ul>
<li>Symbol.iterator()메서드를 사용해 기존 객체가 iterator 객체로 재정의할 수 있다.</li>
</ul>
</li>
</ul>
<p>심볼은 리터럴 형태가 없다.</p>
<pre><code class="language-jsx">let firstName = Symbol(&quot;first name&quot;); // 심볼 내 문자열은 심볼을 구분짓는 역할을 한다.
let person = {};
person[firstName] = &quot;Nicholas&quot;
console.log(person[firstName]); // &quot;Nicholas&quot;
console.log(firstName); // &quot;Symbol(first name)&quot;
</code></pre>
<ul>
<li>심볼 인자에 문자열은 toString() 호출 시 [[Description]] 프로퍼티에 저장된다.</li>
<li>원시 값을 구분하기 위해 typeof 연산자를 사용한 결과는 ‘symbol’ 값을 반환한다.</li>
<li>Object.getOwnPropertySymbols();
<ul>
<li>객체가 갖고있는 심볼들을 반환하는 메서드</li>
</ul>
</li>
</ul>
<h2 id="전역-심볼"><a class="header" href="#전역-심볼">전역 심볼</a></h2>
<ul>
<li>Symbol은 유일한 값과 전역 값을 나눠 사용할 수 있다.</li>
<li>Symbol.for은 전역 심볼 저장소를 검색 후 값이 있으면 반환한다.</li>
<li>Symbol.keyFor(Symbol 값) 메서드는 전역 심볼 저장소의 키를 반환
<ul>
<li>인자로 들어간 심볼 값이 전역 값인지 아닌 지 구분할 수 있다.</li>
</ul>
</li>
<li>전역 심볼은 중복을 피하기 위해 prefix를 사용하는 것이 좋다.</li>
</ul>
<pre><code class="language-jsx">
Symbol('uid') === Symbol('uid') //false
Symbol.for('uid') === Symbol.for('uid') //true

</code></pre>
<h2 id="상용-심볼-well-known-symbols"><a class="header" href="#상용-심볼-well-known-symbols">상용 심볼 (Well-known Symbols)</a></h2>
<ul>
<li>미리 정의되어있는 심볼들</li>
<li>자바스크립트의 API 명세를 개발자들에게 드러내기 위한 수단으로 사용되는 심볼
<ul>
<li>ECMAScript 6</li>
</ul>
</li>
</ul>
<pre><code class="language-jsx">function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}

const auto = new Car('Honda', 'Accord', 1998);

auto instanceof Car // true
Car[Symbol.hasInstance](auto); //true

Car[Symbol.hasInstance](auto) 의 단축문법 === instanceof
</code></pre>
<h2 id="상용-심볼의-예"><a class="header" href="#상용-심볼의-예">상용 심볼의 예</a></h2>
<p>Symbol.hasInstance</p>
<ul>
<li>객체의 상속을 확인하기 위해 instanceof에 의해 사용되는 메서드</li>
<li>모든 함수는 주어진 객체가 그 함수의 인스턴스인지를 확인하는 Symbol.hasInstance를 가진다.</li>
</ul>
<p>Symbol.iterator</p>
<ul>
<li>이터레이터를 반환하는 메서드</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="호이스팅"><a class="header" href="#호이스팅">호이스팅</a></h1>
<ul>
<li>코드에 선언된 변수 및 함수를 유효한 범위의 코드 상단으로 끌어 올리는 작업</li>
<li>var의 변수 / 함수의 선언만 위로 올려지고, 값의 할당은 올려지지 않음</li>
<li>let/const 변수 선언과 함수 표현식에서는 호이스팅이 발생하지 않는다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">JSON</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope"><a class="header" href="#scope">SCOPE</a></h1>
<ul>
<li>변수 혹은 상수에 접근할 수 있는 범위</li>
<li>모듈/함수 내 코드에서 동일한 변수 사용 시 간섭을 줄이는 용도로 사용</li>
<li>Scope는 Global Scope, Local Scope의 타입으로 구분한다.
<ul>
<li>Global Scope: 전역에 선언되어 어디에서도 접근 가능</li>
<li>Local Scope(block {}, function level scope): 특정 지역에 선언되어 해당 지역 내에서만 접근 가능</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="리눅스와-관련된-내용을-정리하는-곳입니다"><a class="header" href="#리눅스와-관련된-내용을-정리하는-곳입니다">리눅스와 관련된 내용을 정리하는 곳입니다.</a></h1>
<h2 id="책-목록"><a class="header" href="#책-목록">책 목록</a></h2>
<ul>
<li>1 : <a href="linux//linux/books/1/introduction.html">실습과 그림으로 배우는 리눅스 구조</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="실습과-그림으로-배우는-리눅스-구조"><a class="header" href="#실습과-그림으로-배우는-리눅스-구조">실습과 그림으로 배우는 리눅스 구조</a></h1>
<h2 id="목차"><a class="header" href="#목차">목차</a></h2>
<ol>
<li><a href="linux/books/1/./chapter1.html">컴퓨터 시스템의 개요</a></li>
<li><a href="linux/books/1/./chapter2.html">사용자 모드로 구현되는 기능</a></li>
<li><a href="linux/books/1/./chater3.html">프로세스 관리</a></li>
<li><a href="linux/books/1/./chapter4.html">프로세스 스케줄러</a></li>
<li><a href="linux/books/1/./chapter5.html">메모리 관리</a></li>
<li><a href="linux/books/1/./chapter6.html">메모리 계층</a></li>
<li><a href="linux/books/1/./chapter7.html">파일 시스템</a></li>
<li><a href="linux/books/1/./chapter8.html">저장 장치</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="컴퓨터-시스템의-개요"><a class="header" href="#컴퓨터-시스템의-개요">컴퓨터 시스템의 개요</a></h1>
<p>OS와 하드웨어의 관계 그리고 OS란 어떤 것인가를 간략하게 보게 된다.</p>
<h3 id="컴퓨터-시스템이-동작할-때-하드웨어에서는-다음-순서가-반복된다"><a class="header" href="#컴퓨터-시스템이-동작할-때-하드웨어에서는-다음-순서가-반복된다">컴퓨터 시스템이 동작할 때 하드웨어에서는 다음 순서가 반복된다.</a></h3>
<ol>
<li>입력 장치 혹은 네트워크 어댑터를 통해서 컴퓨터에 무언가 처리 요청이 들어온다.</li>
<li><strong>메모리에 있는 명령을 읽어 CPU에서 실행하고 그 결과 값을 다시 메모리의 다른 영역에 기록한다.</strong></li>
<li>메모리의 데이터를 하드디스크(HDD)나 SSD 등의 저장 장치에 기록 또는 네트워크를 통해 다른 컴퓨터에 전송하거나 디스플레이 등의 출력 장치를 통해 사람에게 결과 값을 보여준다.</li>
<li>1번부터 반복해서 실행한다.</li>
</ol>
<h3 id="프로그램은-크게-다음과-같은-종류로-나뉠-수-있다"><a class="header" href="#프로그램은-크게-다음과-같은-종류로-나뉠-수-있다">프로그램은 크게 다음과 같은 종류로 나뉠 수 있다.</a></h3>
<ul>
<li>어플리케이션: 사용자가 직접 사용하는 프로그램</li>
<li>미들웨어: 여러 가지 어플리케이션이 공통으로 사용하는 처리를 묶어서 애플리케이션의 실행을 도와준다. 예를 들어 웹 서버, 데이터베이스 등이 있다. 애플리케이션과 OS의 중간자 역할을 한다.</li>
<li>OS(운영체제): 하드웨어를 직접 조작하여 어플리케이션이나 미들웨어의 실행에 필요한 기능을 제공한다.
<ul>
<li>OS는 여러 가지 프로그램을 프로세스라고 하는 단위로 실행한다.</li>
</ul>
</li>
</ul>
<h3 id="리눅스와-하드웨어의-관계"><a class="header" href="#리눅스와-하드웨어의-관계">리눅스와 하드웨어의 관계</a></h3>
<p><strong>리눅스의 중요한 역할은 외부 장치(이하 디바이스)를 조작하는 일이다.</strong> </p>
<p>리눅스 같은 OS가 없으면 여러 개의 프로세스가 각각 디바이스를 조작하는 코드를 작성해야 한다.
리눅스는 디바이스 드라이버라고 하는 프로그램을 통해 디바이스를 다룬다.</p>
<p>CPU에는 커널 모드와 사용자 모드라고 하는 두 가지 모드가 있으며 커널 모드로 동작할 때만 디바이스에 접근할 수 있다.
디바이스 드라이버는 커널 모드로 동작하고 프로세스는 사용자 모드로 동작한다.</p>
<p><strong>커널모드에서 동작하는 것들</strong></p>
<ul>
<li>프로세스 관리 시스템</li>
<li>프로세스 스케줄링</li>
<li>메모리 관리 시스템</li>
</ul>
<p>OS의 핵심 부분이 되는 처리를 모아 담당하는 프로그램을 <strong>커널</strong>이라고 부른다.
프로세스가 디바이스 드라이버를 포함한 커널이 제공하는 기능을 사용하려 할 때는 <strong>시스템 콜</strong>이라고 하는 특수한 처리를 통해 커널에 요청한다.
커널은 시스템에 탑재된 CPU나 메모리 등의 리소스를 관리하고 있으며 리소스의 일부를 시스템에 존재하는 각 프로세스에 적절히 분배한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="사용자-모드로-구현되는-기능"><a class="header" href="#사용자-모드로-구현되는-기능">사용자 모드로 구현되는 기능</a></h1>
<p>사용자 모드는 라이브러리 형태인 것도 있고 단독 프로그램으로 동작하는 것도 있다.</p>
<h2 id="시스템-콜"><a class="header" href="#시스템-콜">시스템 콜</a></h2>
<ul>
<li>프로세스는 프로세스의 생성이나 하드웨어의 조작 등 커널의 도움이 필요할 경우 시스템 콜을 통해 커널에 처리를 요청합니다.</li>
</ul>
<h3 id="시스템-콜의-종류"><a class="header" href="#시스템-콜의-종류">시스템 콜의 종류</a></h3>
<ul>
<li>프로세스 생성, 삭제</li>
<li>메모리 확보, 해제</li>
<li>프로세스 간 통신 (IPC)</li>
<li>네트워크</li>
<li>파일시스템 다루기</li>
<li>파일 다루기 (디바이스 접근)</li>
</ul>
<h3 id="cpu의-모드-변경"><a class="header" href="#cpu의-모드-변경">CPU의 모드 변경</a></h3>
<ul>
<li>시스템 콜은 CPU의 특수한 명령을 실행해야만 호출된다. 프로세스는 보통 사용자 모드로 실행되고 있지만 커널에 처리를 요청하고자 시스템 콜을 호출하면 CPU에서는 인터럽트 이벤트가 발생한다.</li>
<li>인터럽트 이벤트가 발생하면 CPU는 사용자 모드에서 커널 모드로 변경되며 요청한 내용을 처리하기 위해 커널이 동작하기 시작한다.</li>
<li>요청한 내용 처리가 끝나면 커널 내의 시스템 콜 처리가 종료된다. 그리고 다시 사용자 모드로 돌아가 프로세스의 동작을 계속 진행한다.</li>
</ul>
<p>커널은 프로세스가 요청한 내용을 처리하기 전에 프로세스의 요구가 유효한지 확인한다.
요구 사항이 맞지 않는다면 커널은 시스템 콜을 실패했다고 처리한다.
(예를 들어 시스템의 메모리 용량 이상의 메모리를 요구하는 것 등)</p>
<h3 id="시스템-콜-호출의-동작-순서"><a class="header" href="#시스템-콜-호출의-동작-순서">시스템 콜 호출의 동작 순서</a></h3>
<pre><code class="language-c">
$ cc -o hello hello.c
$ cc -o hello hello.py

/* 
cc 시스템 콜 로그를 출력하는 커맨드
-o strace 출력을 별도로 저장하기 위한 output 옵션
*/

</code></pre>
<p>어플리케이션 코드 작성을 위한 프로그램 언어가 무엇이든 상관없이 프로그램이 커널에 요청을 할 때 사용되는 시스템 콜을 호출하는 코드는 동일하다는 것을 알 수 있다.</p>
<p>프로세스가 사용자 모드와 커널 모드 중 어느 쪽에서 실행되고 있는 지의 비율은 'sar' 명령어로 확인할 수 있다.</p>
<pre><code>
$ sar -P ALL 1 //각 CPU 코어가 어떤 종류의 처리를 실행하고 있는 지를 1초 단위로 측정한다.

</code></pre>
<h3 id="시스템-콜-명령어"><a class="header" href="#시스템-콜-명령어">시스템 콜 명령어</a></h3>
<ul>
<li>getppid() : 부모 프로세스의 프로세스 ID를 얻는 명령어 (get parent process id)</li>
<li>kill <code>process id</code>: 프로세스를 종료</li>
<li>strace -T : 각종 시스템 콜 처리에 걸린 시간을 마이크로초 단위로 정밀하게 측정할 수 있다.</li>
</ul>
<h2 id="시스템-콜의-wrapper-함수--시스템-콜을-호출하는-일만-하는-함수"><a class="header" href="#시스템-콜의-wrapper-함수--시스템-콜을-호출하는-일만-하는-함수">시스템 콜의 Wrapper 함수 = 시스템 콜을 호출하는 일만 하는 함수</a></h2>
<p>리눅스에는 프로그램의 작성을 도와주기 위해 프로세스 대부분에 필요한 여러 라이브러리 함수가 있다.
시스템 콜은 보통의 함수 호출과는 다르게 C언어 등의 고급언어에서는 직접 호출이 불가능하다.
아키텍처에 의존하는 어셈블리 코드를 사용해 호출할 필요가 있다.</p>
<p>이러한 문제를 해결하기 위해서 OS는 내부적으로 시스템 콜을 호출하는 일만 하는 함수를 제공하는 데 이를 시스템 콜 wrapper라고 한다.</p>
<h2 id="표준-c-라이브러리"><a class="header" href="#표준-c-라이브러리">표준 C 라이브러리</a></h2>
<p>C 언어에는 ISO에 의해 정해진 표준 라이브러리가 있다.
리눅스에도 이 표준 C라이브러리가 제공되고 있다.
보통은 GNU 프로젝트가 제공하는 glibc를 표준 C라이브러리로 사용한다.
대부분의 C 프로그램은 glibc를 링크하고 있다.</p>
<p>glibc는 시스템 콜의 wrapper 함수를 포함한다.
또한 POSIX 규격에 의해 정의된 함수도 제공한다.</p>
<p>POSIX: 유닉스 계열의 OS가 갖추어야 할 각종 기능을 정해둔 규격
GNU 프로젝트: 유닉스와 호환되는 자유 소프트웨어를 개발하는 프로젝트</p>
<ul>
<li>프로그램을 어떠한 목적으로도 시행할 수 있는 자유</li>
<li>프로그램이 어떻게 동작하는지 학습하고 자신의 필요에 맞게 개박할 수 있는 자유, 이를 위해서는 소스코드에 대한 접근이 전제되어야 한다.</li>
<li>이웃을 돕도록 복제물을 재배포할 수 있는 자유</li>
<li>프로그램을 개선할 수 있는 자유와 개선된 이점을 공동체 전체가 누리도록 발표할 수 있는 자유, 이를 위해서도 역시 소스코드에 대한 접근이 전제되어야 한다.
ISO: 국제 표준화 기구</li>
</ul>
<pre><code>
$ ldd /bin/echo

ldd: 프로그램이 어떠한 라이브러리를 링크하고 있는 지 알 수 있는 명령어

</code></pre>
<h2 id="os가-제공하는-프로그램"><a class="header" href="#os가-제공하는-프로그램">OS가 제공하는 프로그램</a></h2>
<p>OS가 제공하는 프로그램은 OS가 제공하는 라이브러리와 마찬가지로 대부분의 프로그램이 필요하다
OS의 동작을 변경시키는 프로그램도 OS의 일부로써 제공된다.</p>
<ul>
<li>시스템 초기화: init</li>
<li>OS의 동작을 바꿈: sysctl, nice, sync</li>
<li>파일 관련: touch, mkdir</li>
<li>텍스트 데이터 가공: grep, sort, uniq</li>
<li>성능 측정: sar, iostat</li>
<li>컴파일러: gcc</li>
<li>스크립트 언어 실행 환경: perl, python, ruby</li>
<li>셀: bash</li>
<li>윈도우 시스템: X</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로세스-관리"><a class="header" href="#프로세스-관리">프로세스 관리</a></h1>
<h2 id="프로세스-생성의-목적"><a class="header" href="#프로세스-생성의-목적">프로세스 생성의 목적</a></h2>
<p>리눅스에서는 두 가지 목적으로 프로세스를 생성한다.</p>
<ol>
<li>같은 프로그램의 처리를 여러 개의 프로세스가 나눠서 처리한다. 예를 들어 웹 서버처럼 리퀘스트가 여러 개 들어왔을 때 동시에 처리해야 하는 경우</li>
<li>전혀 다른 프로그램을 생성합니다. 예를 들어 bash로부터 각종 프로그램을 새로 생성하는 경우</li>
</ol>
<h3 id="fork-함수"><a class="header" href="#fork-함수">fork() 함수</a></h3>
<p>목적1을 수행하는 함수이다.
fork 함수를 실행하면 실행한 프로세스와 함께 새로운 프로세스가 1개가 커널 메모리로부터 생성된다.
생성 전의 프로세스를 부모 프로세스(parent process), 새롭게 생성된 프로세스를 자식 프로세스(child process)라고 부릅니다.</p>
<ol>
<li>자식 프로세스용 메모리 영역을 작성하고 거기에 부모 프로세스의 메모리를 복사한다</li>
<li>fork 함수의 리턴 값이 각기 다른 것을 이용하며 부모 프로세스와 자식 프로세스가 서로 다른 코드를 실행하도록 분기한다.</li>
</ol>
<h3 id="execve-함수"><a class="header" href="#execve-함수">execve() 함수</a></h3>
<p>전혀 다른 프로그램을 생성할 때에는 execve() 함수를 사용한다.</p>
<ol>
<li>실행 파일을 읽은 다음 프로세스의 메모리 맵에 필요한 정보를 읽어들인다.</li>
<li>현재 프로세스의 메모리를 새로운 프로세스의 데이터로 덮어쓴다.</li>
<li>새로운 프로세스의 첫 번째 명령부터 실행한다.</li>
</ol>
<p>즉, 전혀 다른 프로그램을 생성하는 경우 프로세스의 수가 증가하는 것이 아니라 기존의 프로세스를 별도의 프로세스로 변경하는 방식으로 수행된다.
리눅스의 실행 파일은 실제로는 위에서 설명한 것 같은 단순한 것이 아니라 'ELF Executable and Linkable Format'라는 형식을 사용한다.
ELF 형식의 각종 정보는 'readelf' 명령어로 자세히 볼 수 있다.</p>
<pre><code>
$ readelf -h /bin/sleep

# readelf : ELF 형식의 각종 정보를 출력하는 명령어

</code></pre>
<h3 id="fork-and-exec-방식"><a class="header" href="#fork-and-exec-방식">fork and exec 방식</a></h3>
<p>bash 에서 echo를 실행하는 과정</p>
<ol>
<li>bash 메모리를 기준으로 fork()를 통해 자식 프로세스를 생성</li>
<li>자식 프로세스를 다른 프로그램으로 대체하기 위해 exec() 실행</li>
<li>echo의 메모리가 되어 echo 프로그램을 실행</li>
</ol>
<h3 id="_exit"><a class="header" href="#_exit">_exit()</a></h3>
<p>프로그램 종료는 '_exit()'함수를 사용한다.
( 내부에서는 exit_group() 시스템 콜을 호출한다 )
이 함수를 이용하면 할당된 메모리를 전부 회수한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로세스-스케줄러"><a class="header" href="#프로세스-스케줄러">프로세스 스케줄러</a></h1>
<p>리눅스 커널에는 '프로세스 스케줄러' 기능이 있는데 이 기능은 여러 개의 프로세스를 동시에 동작시킨다. 정확히는 동시에 동작시키는 것처럼 보이게 한다.</p>
<ul>
<li>
<p>하나의 CPU는 동시에 하나의 프로세스만 처리할 수 있다.</p>
</li>
<li>
<p>하나의 CPU에 여러 개의 프로세스를 실행해야 할 때는 각 프로세스를 적절한 시간으로 쪼개서(타임 슬라이스) 번갈아 처리한다.</p>
</li>
<li>
<p>프로세스를 종료시킬 때까지의 경과 시간은 프로세스 수에 비례하여 증가한다.</p>
</li>
<li>
<p>각 프로세스는 대략 같은 타임 슬라이스를 가진다.</p>
</li>
</ul>
<h2 id="라운드-로빈"><a class="header" href="#라운드-로빈">라운드 로빈</a></h2>
<ul>
<li>프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(타임 퀀텀)로 CPU를 할당하는 방식</li>
</ul>
<h2 id="컨텍스트-스위치"><a class="header" href="#컨텍스트-스위치">컨텍스트 스위치</a></h2>
<p>논리 CPU상에서 동작하는 프로세스가 바뀌는 것을 '컨텍스트 스위치'라고 부른다.</p>
<h2 id="프로세스의-상태"><a class="header" href="#프로세스의-상태">프로세스의 상태</a></h2>
<p>프로세스의 상태는 다음과 같다.</p>
<ul>
<li>실행 상태: 현재 논리 CPU를 사용하고 있다</li>
<li>실행 대기 상태: CPU 시간이 할당되기를 기다리고 있다.</li>
<li>슬립 상태: 이벤트가 발생하기를 기다리고 있으며 이벤트 발생까지는 CPU시간을 사용하지 않는다.</li>
<li>좀비 상태: 프로세스가 종료한 뒤 부모 프로세스가 종료 상태를 인식할 때까지 기다리고 있다.</li>
</ul>
<h2 id="idle-상태"><a class="header" href="#idle-상태">idle 상태</a></h2>
<ul>
<li>'아무것도 하지 않는' 특수한 프로세스가 동작한다.</li>
<li>시스템 전체가 CPU 시간을 거의 사용하지 않을 때</li>
</ul>
<h2 id="스루풋과-레이턴시"><a class="header" href="#스루풋과-레이턴시">스루풋과 레이턴시</a></h2>
<p>각종 성능지표인 스루풋과 레이턴시에 대해 정리한다.</p>
<ul>
<li>스루풋: 단위 시간당 처리된 일의 양이며 높을수록 좋다. 
( 완료한 프로세스의 수 / 경과 시간 )</li>
<li>레이턴시: 각각의 처리가 시작부터 종료까지의 경과된 시간으로 짧을수록 좋다. 
( 처리 종료 시간 - 처리 시작 시간 )</li>
</ul>
<h2 id="실제-시스템"><a class="header" href="#실제-시스템">실제 시스템</a></h2>
<p>실제 시스템에 돌아가는 논리 CPU는 다음과 같은 상태를 정신 없이 오고 간다.</p>
<ul>
<li>idle 상태: 논리 CPU가 쉬고 있기 때문에 스루풋이 떨어지는 경향이 있다.</li>
<li>프로세스가 동작 중: 실행 대기의 프로세스가 없기 때문에 이상적인 상태이다. 그러나 이러한 상태는 다음의 프로세스가 실행 가능한 상태가 되면, 2개의 프로세스의 레이턴시가 양쪽 다 길어진다.</li>
<li>프로세스가 대기 중: 실행 대기 프로세스가 있다. 스루풋은 높지만 레이턴시가 길어지는 경향이 있다.</li>
</ul>
<h2 id="논리-cpu가-여러-개일-때-스케줄링"><a class="header" href="#논리-cpu가-여러-개일-때-스케줄링">논리 CPU가 여러 개일 때 스케줄링</a></h2>
<p>논리 CPU가 여러 개일 때 스케줄링은 어떻게 될까? 이 때는 로드밸런서 혹은 글로벌 스케줄러라는 기능이 동작한다. 로드밸런서란 여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할을 한다.
프로세스를 할당받은 각 논리 CPU안에서 1개의 논리 CPU가 있을 떄와 마찬가지로 각 프로세스에 공평하게 CPU 시간을 분배한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="메모리-관리"><a class="header" href="#메모리-관리">메모리 관리</a></h1>
<p>리눅스는 커널의 메모리 관리 시스템으로 시스템에 탑재된 메모리를 관리한다.
메모리는 각 프로세스가 사용하는 것은 물론이고 커널 자체도 메모리를 사용한다.</p>
<h2 id="메모리-통계-정보"><a class="header" href="#메모리-통계-정보">메모리 통계 정보</a></h2>
<ul>
<li>total: 시스템에 탑재된 전체 메모리 용량</li>
<li>free: 표기상 이용하지 않는 메모리</li>
<li>buff/cache: 버퍼 캐시 또는 페이지 캐시가 이용하는 메모리. 시스템의 빈 메모리가 부족하면 커널이 해제한다.</li>
<li>available: 실질적으로 사용 가능한 메모리이다. free 필드 값의 메모리가 부족하면 해제되는 커널 내의 메모리 영역 사이즈를 더한 값으로, 해제될 수 있는 메모리에는 버퍼 캐시나 페이지 캐시의 대부분 혹은 다른 커널 내의 메모리 일부가 포함된다.
available 메모리 영역이 부족해지면 Out of Memory 현상이 일어난다.
OOM 현상으로 인해 OOM Killer라는 기능이 존재하는데
이 기능은 적절한 프로세스를 임의로 선택해 강제 종료하여 메모리 영역을 해제시킨다.</li>
</ul>
<h2 id="단순한-메모리-할당"><a class="header" href="#단순한-메모리-할당">단순한 메모리 할당</a></h2>
<p>먼저 가상 메모리가 없는 단순한 경우와 가상 메모리가 없어서 생기는 문제점에 대해 설명하겠다.</p>
<p>커널이 프로세스에 메모리를 할당하는 일은 크게 두 가지 타이밍이 벌어진다.</p>
<ol>
<li>프로세스를 생성할 때</li>
<li>프로세스를 생성한 뒤 추가로 동적 메모리를 할당할 때</li>
</ol>
<p>2의 동작의 경우 프로세스가 생성된 뒤 추가로 메모리가 더 필요하면 프로세스는 커널에 메모리 확보용 시스템 콜을 호출해서 메모리 할당을 요청한다.
커널은 메모리 할당 요청을 받으면 필요한 사이즈를 빈 메모리 영역으로부터 잘라내 그 영역의 시작 주소값을 반환한다.</p>
<p>이러한 메모리 할당 방법에는 문제점들이 있다.</p>
<ol>
<li>메모리 단편화 (memory fragmentation)</li>
<li>다른 용도의 메모리 접근 가능</li>
<li>여러 프로세스를 다루기 곤란</li>
</ol>
<h3 id="메모리-단편화"><a class="header" href="#메모리-단편화">메모리 단편화</a></h3>
<p>프로세스가 생성된 뒤 메모리의 획득, 해제를 반복하면 메모리 단편화 문제가 발생한다.
큰 메모리를 한번에 할당할 떄 문제가 됨</p>
<ul>
<li>프로그램은 메모리를 획득할 때마다 얻은 메모리가 몇 개의 영역에 나누어져 있는 지 확인해야 하므로 매우 불편하다</li>
<li>더 큰 용도의 메모리 할당에 문제가 생길 수 있다.</li>
</ul>
<h2 id="가상-메모리"><a class="header" href="#가상-메모리">가상 메모리</a></h2>
<p>가상 메모리는 간단하게 설명하면 시스템에 탑재된 메모리를 프로세스가 직접 접근하지 않고 가상 주소라는 주소를 사용하여 간접적으로 접근하도록 하는 방식이다.
프로세스에 보이는 메모리 주소를 '가상 주소', 시스템에 탑재된 메모리의 실제 주소를 '물리 주소'라고 부른다.
또한 주소에 따라서 접근 가능한 범위를 '가상 주소 공간'이라고 부른다.</p>
<h3 id="페이지-테이블"><a class="header" href="#페이지-테이블">페이지 테이블</a></h3>
<p>가상 주소에서 물리 주소로 변환하는 과정은 커널 내부에 보관되어 있는 '페이지 테이블'이라는 표를 사용한다. 가상 메모리는 전체 메모리를 페이지라는 단위로 나눠서 관리하고 있어서 변환은 페이지 단위로 이루어진다.</p>
<p>페이지 테이블에서 한 페이지에 대한 데이터를 '페이지 테이블 엔트리'라고 부르며 이 페이지 테이블 엔트리에는 가상 주소와 물리 주소의 대응 정보가 들어있다.
페이지 사이즈는 CPU 아키텍쳐에 따라 다르다. 흔히 사용하는 x86_64 아키텍쳐의 페이지 사이즈는 4킬로바이트이다.</p>
<p>물리 메모리에 매핑되어 있지 않은 가상 메모리에 접근을 하게되면 CPU에는 '페이지 폴트'라는 인터럽트가 발생한다. 페이지 폴트에 의해 현재 실행 중인 명령이 중단되고 커널 내의 '페이지 폴트 핸들러'라는 인터럽트 핸들러가 동작한다. 커널은 프로세스로부터 메모리 접근이 잘못되었다는 내용을 페이지 폴트 핸들러에 알려준다. 그 뒤 'SIGSEGV' 시그널을 프로세스에 통지한다. 이 시그널을 받은 프로세스는 강제로 종료된다.</p>
<h2 id="프로세스에-메모리를-할당할-때"><a class="header" href="#프로세스에-메모리를-할당할-때">프로세스에 메모리를 할당할 때</a></h2>
<p>커널이 프로세스를 생성할 때나 추가로 메모리를 요청받을 때, 가상 메모리를 통하여 어떻게 프로세스에 메모리를 할당하고 있는 지 살펴본다.</p>
<p>프로그램을 실행하는데 필요한 메모리 사이즈는 '코드 영역 사이즈 + 데이터 영역 사이즈'이다.
리눅스에서 실제 물리 메모리 할당은 '디맨드 페이징'이라는 방식을 사용한다.</p>
<h2 id="가상-메모리-응용"><a class="header" href="#가상-메모리-응용">가상 메모리 응용</a></h2>
<ul>
<li>파일 맵</li>
<li>디맨드 페이징</li>
<li>Copy on Write 방식의 고속 프로세스 생성</li>
<li>스왑(Swap)</li>
<li>계층형 페이지 테이블</li>
<li>Hupe page</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="메모리-계층"><a class="header" href="#메모리-계층">메모리 계층</a></h1>
<p>메모리 장치의 계층 구조를 도식화한 그림</p>
<p>레지스터<br />
캐시 메모리
메모리
저장 장치</p>
<p>아래부터 위</p>
<ul>
<li>사이즈 큼 -&gt; 작음</li>
<li>가격 쌈 -&gt; 비쌈</li>
<li>접근속도 느림 -&gt; 빠름</li>
</ul>
<h2 id="캐시-메모리"><a class="header" href="#캐시-메모리">캐시 메모리</a></h2>
<p>컴퓨터의 동작흐름은 아래와 같다</p>
<ol>
<li>명령어를 바탕으로 메모리에서 레지스터로 데이터를 읽는다.</li>
<li>레지스터에 있는 데이터를 바탕으로 계산한다.</li>
<li>계산 결과를 메모리에 쓴다.</li>
</ol>
<p>캐시 메모리는 레지스터 안에서 계산하는 것과 메모리에 접근하는 것, 양쪽의 처리 시간의 차이를 메우는 역할을 한다.</p>
<p>캐시 메모리로부터 레지스터에 접근할 때의 레이턴시는 메모리에 접근할 때와 비교해보면 수배에서 수십배 빠른 점을 이용해 속도를 고속화한다. 캐시 메모리는 일반적으로 CPU에 내장되어 있지만 CPU의 바깥에 있는 캐시 메모리도 있다.</p>
<p>메모리에서 레지스터로 데이터를 읽어올 때는, 일단 캐시 메모리에 읽어온 뒤 같은 내용을 다시 레지스터로 읽어들인다. 이때 읽어오는 크기는 CPU에서 정한 '캐시 라인 사이즈'만큼이다.</p>
<p>메모리로부터 읽어 들인 데이터가 변경되었음을 플래그로 표시하는 데 이 표시된 라인을 '더티'라고 한다.
이 더티 플래그가 붙어 있는 데이터는 나중에 백그라운드 처리로 메모리에 다시 기록된다. 다시 기록되면 더티 플래그는 사라진다.</p>
<h3 id="캐시-메모리가-가득-찬-경우"><a class="header" href="#캐시-메모리가-가득-찬-경우">캐시 메모리가 가득 찬 경우</a></h3>
<p>캐시 메모리가 가득 찬 경우, 캐시 메모리에 존재하지 않는 데이터를 추가로 읽으면 기존의 캐시 메모리 중 1개를 파기한다. 파기되어 비워진 라인에 새 데이터를 넣는다.</p>
<p>캐시 메모리가 가득 차고 모든 캐시 라인이 더티라면 메모리 접근을 할 때마다 캐시 라인 안의 데이터가 자주 바뀌는 스래싱이 발생하여 성능이 크게 감속할 수 있다.</p>
<h3 id="메모리-참조의-국소성"><a class="header" href="#메모리-참조의-국소성">메모리 참조의 국소성</a></h3>
<p>(국소성: 충분히 멀리 떨어진 두 물체는 곧바로 상용하지 않는다는 원리)</p>
<p>프로세스의 데이터가 전부 캐시에 있는 동안에는 데이터에 접근하는 속도는 메모리에 접근하는 속도가 아니라 이보다 빠른 캐시에 접근하는 속도이다. 프로그램은 대부분 메모리 참조의 국소성이라고 하는 다음과 같은 특성이 있다.</p>
<ul>
<li>시간 국소성: 특정 시점에서 접근하는 데이터는 가까운 미래에 다시 접근할 가능성이 크다. 전형적인 예로는 루프 처리중인 코드 영역을 들 수 있다.</li>
<li>공간 국소성: 특정 시점에 어떤 데이터에 접근하면 그 데이터와 가까운 주소에 있는 데이터를 접근할 확률이 높다. 전형적인 예로는 배열의 전체 검색 등을 들 수 있다.</li>
</ul>
<p>이러한 이유로 프로세스는 짧은 시간을 놓고 생각해보면, 자신이 획득한 메모리의 총량보다 훨씬 좁은 범위의 메모리에 접근하는 성향이 있다. 이 좁은 범위를 캐시 메모리의 사이즈가 커버할 수 있으면 성능이 좋은 것이다.</p>
<h3 id="정리"><a class="header" href="#정리">정리</a></h3>
<p>프로그램의 워크로드를 캐시 메모리 사이즈에 들어가게 하는 것으로 성능을 크게 향상시킬 수 있다.
속도를 중요시하는 프로그램이라면 캐시 메모리의 효과를 최대한으로 끌어내기 위해 데이터의 배열이나 알고리즘 혹은 설정을 연구해서 단위 시간 당 메모리 접근 범위를 작게 하는 것이 중요하다.</p>
<p>한편, 시스템 설정을 변경했을 때 프로그램의 성능이 크게 나빠진 경우에는 프로그램의 데이터가 캐시 메모리에 전부 들어가지 않았을 가능성이 있다.</p>
<h2 id="translation-lookaside-buffer"><a class="header" href="#translation-lookaside-buffer">Translation Lookaside Buffer</a></h2>
<p>프로세스는 다음과 같은 순서에 따라 가상 주소의 데이터에 접근한다.</p>
<ol>
<li>물리 메모리상에 존재하는 페이지 테이블을 참고하여 가상 주소를 물리 주소로 변환한다.</li>
<li>1에서 구한 물리 메모리에 접근한다.</li>
</ol>
<p>캐시 메모리를 사용하여 고속화하는 것은 2번뿐이다. 왜냐하면 1은 물리 메모리상에 있는 페이지 테이블에 접근해야 하므로 캐시가 동작할 수 없다.</p>
<p>이 문제를 해결하기 위해 CPU에는 가상 주소에서 물리 주소로의 변환표를 보관하는 한편, 캐시 메모리와 똑같이 고속으로 접근 가능한 TLB 라는 영역이 있다. 이것을 가지고 1을 고속화 한다.</p>
<h3 id="페이지-캐시"><a class="header" href="#페이지-캐시">페이지 캐시</a></h3>
<p>CPU로부터 메모리에 접근하는 속도에 비해 저장 장치에 접근하는 속도는 엄청나게 느리다.
이 속도 차이를 줄이기 위해 커널에는 '페이지 캐시'기능이 있다.</p>
<p>페이지 캐시는 캐시 메모리와 매우 비슷하다
캐시 메모리가 메모리의 데이터를 캐싱하느 ㄴ것과 비슷하게 페이지 캐시는 저장 장치 내의 파일 데이터를 메모리에 캐싱한 것이다.</p>
<p>캐시 메모리는 캐시 라인 단위로 데이터를 다루지만 페이지 캐시는 페이지 단위로 데이터를 다룬다.
페이지 캐시의 동작 흐름을 구체적으로 살펴본다.</p>
<p>프로세스가 파일의 데이터를 읽어 들이면 커널은 프로세스의 메모리에 파일의 데이터를 직접 복사하는 것이 아니라 커널의 메모리 내에 있는 페이지 캐시라는 영역에 복사한 뒤 이 데이터를 프로세스 메모리에 복사한다.</p>
<p>커널은 자신의 메모리 안에 페이지 캐시에 캐싱한 파일과 그 범위 등의 정보를 보관하는 관리 영역을 가지고 있다.</p>
<p>그리고 페이지 캐시에 존재하는 데이터를 다시 읽으면 커널은 페이지 캐시의 데이터를 돌려준다.</p>
<p>이 방법은 저장 장치에 접근하는 경우에 비해 훨씬 더 빠르게 처리된다.
또한 페이지 캐시는 전체 프로세스 공유의 자원이므로 읽어 들인 프로세스는 최초에 파일 데이터에 접근한 프로세스와 다른 프로세스여도 문제가 없다.</p>
<h3 id="페이지-캐시-쓰기"><a class="header" href="#페이지-캐시-쓰기">페이지 캐시 쓰기</a></h3>
<p>프로세스가 데이터를 파일에 쓰면 커널은 페이지 캐시에 데이터를 쓴다.
이때 관리 영역 내에 해당하는 데이터에 대응되는 엔트리에 '데이터의 내용은 저장 장치의 내용보다 새로운 것'이라는 플래그를 붙여둔다. 이 플래그가 붙은 페이지를 더티 페이지라고 부른다.</p>
<p>이것도 읽기와 마찬가지로 저장 장치에 접근하는 것에 비해 훨씬 더 빠르게 처리된다.
더티 페이지의 내용은 나중에 커널의 백그라운드로 처리하며 스토리지 내의 파일에 반영한다.
이때 더티 페이지의 플래그를 지운다.</p>
<p>각 프로세스가 접근하는 파일의 데이터가 전부 페이지 캐시에 있으면 시스템 파일의 접근 속도는 저장 장치의 접근 속도가 아닌 메모리 접근 속도에 근접하므로 시스템 전체가 빠르게 동작한다.</p>
<p>또한 페이지 캐시 사이즈는 시스템의 메모리가 비어 있는 한, 시스템 내의 각 프로세스가 페이지 캐시에 없는 파일을 읽을 때마다 점점 증가한다.</p>
<p>시스템 메모리가 부족해지면 커널은 페이지 캐시를 해제하여 빈 영역을 만든다. 이 경우 더티가 아닌 페이지를 파기한다. 그래도 시스템 메모리가 부족하면 더티 페이지를 라이트 백 한 뒤에 파기한다.
더티 페이지는 저장 장치 접근이 발생하므로 시스템의 성능이 느려지는 문제점이 있다. 파일에 쓰기가 많아서 더티 페이지가 많아지는 시스템은 부하가 많아질 수 밖에 없다. 메모리 부족이 더티 페이지의 라이트 백을 자주 발생시켜 시스템이 느려지는 일은 굉장히 자주 있다.</p>
<h2 id="버퍼-캐시"><a class="header" href="#버퍼-캐시">버퍼 캐시</a></h2>
<p>페이지 캐시와 비슷한 구조로 버퍼 캐시라는 것이 있다.
이것은 파일시스템을 사용하지 않고 나중에 설명할 디바이스 파일을 이용하여 저장 장치에 직접 접근하는 등의 목적으로 사용한다.</p>
<p>페이지 캐시와 버퍼 캐시를 합쳐서 저장 장치 안의 데이터를 메모리에 넣어두는 방식이라 한다.</p>
<h2 id="정리-1"><a class="header" href="#정리-1">정리</a></h2>
<p>파일의 데이터가 페이지 캐시에 있다면 없는 경우와 비교해서 파일 접근이 매우 빨라진다.
그렇게 하기 위해서는 시스템이 접근하는 파일의 사이즈나 물리 메모리의 양을 비교하여 맞추는 것이 중요하다.</p>
<p>설정 변경이나 시간이 지나면서 시스템의 성능이 갑자기 느려졌다면 파일의 데이터가 페이지 캐시에 제대로 들어가지 못했을 수 있다. 여러가지 sysctl 파라미터를 잘 튜닝한다면 페이지 캐시의 라이트 백이 자주 발생하여서 생기는 I/O 부하를 막을 수 있다. 또한 sar - B나 sar -d -p등을 이용하여 페이지 캐시에 관한 통계 정보를 얻을 수 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="파일-시스템"><a class="header" href="#파일-시스템">파일 시스템</a></h1>
<p>리눅스에서는 저장 장치 안의 데이터에 접근할 때 일반적으로 직접 저장 장치에 접근하지 안혹 편의를 위해 파일 시스템을 통해 접근한다.</p>
<p>저장 장치의 기능은 단순하게 말하면 '저장 장치 안에 지정뙨 주소에 대해 특정 사이즈의 데이터를 읽거나 씀'이다. </p>
<p>저장 장치안에 어디에 어느 정도의 데이터가 있는 지 어디가 빈 영역인지를 관리하는 방법이 파일 시스템이다.</p>
<h2 id="리눅스의-파일시스템"><a class="header" href="#리눅스의-파일시스템">리눅스의 파일시스템</a></h2>
<p>파일을 카테고리별로 정리할 수 있도록 리눅스의 파일시스템에는 디렉터리 라고 부르는 파일을 보관하는 특수한 파일이 존재한다.
디렉터리 안에는 일반적인 파일 또는 다른 디렉터리를 보관하는 것이 가능하며 각각 다른 디렉터리 안에 존재한다면 여러파일이 같은 이름을 가져도 된다. 이러한 방식을 위해 리눅스의 파일시스템은 트리구조로 되어있다.</p>
<p>리눅스가 다루는 파일 시스템은 'ext4', 'XFS', 'Btrfs'등 1개 이상이다.</p>
<h2 id="데이터와-메타데이터"><a class="header" href="#데이터와-메타데이터">데이터와 메타데이터</a></h2>
<p>데이터: 사용자가 작성한 문서나 사진, 동영상, 프로그램 등의 내용
메타데이터: 파일의 이름이나 저장 장치 내에 위치 사이즈 등의 보조 정보</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="저장-장치"><a class="header" href="#저장-장치">저장 장치</a></h1>
<h2 id="hdd의-데이터-읽기-쓰기의-동작-방식"><a class="header" href="#hdd의-데이터-읽기-쓰기의-동작-방식">HDD의 데이터 읽기 쓰기의 동작 방식</a></h2>
<p>HDD는 자기 정보로 변환하여 그것을 플래터라고 불리는 자기 장치에 기록하는 저장 장치이다.
데이터는 바이트 단위가 아닌 섹터라고 불리는 단위로 읽고 쓴다.</p>
<p>플래터의 각 섹터 데이터는 자기 헤드라는 부품에 의해 읽고 쓴다.
자기 헤드는 스윙 암이라는 부품에 달려있으며 스윙 암이 움직임으로써 자기 헤드를 플래터의 동심원 반경 방향으로 이동시킨다.
여기에 플래터를 회전시킴으로써 자기 헤드를 읽고 싶은 대상 섹터의 바로 위에 오도록 한다</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
