<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Be_Software_Engineer</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="javascript/introduction.html"><strong aria-hidden="true">2.</strong> Javascript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript/var.html"><strong aria-hidden="true">2.1.</strong> var</a></li><li class="chapter-item expanded "><a href="javascript/data.html"><strong aria-hidden="true">2.2.</strong> data</a></li><li class="chapter-item expanded "><a href="javascript/hoisting.html"><strong aria-hidden="true">2.3.</strong> hosting</a></li><li class="chapter-item expanded "><a href="javascript/json.html"><strong aria-hidden="true">2.4.</strong> json</a></li><li class="chapter-item expanded "><a href="javascript/scope.html"><strong aria-hidden="true">2.5.</strong> scope</a></li></ol></li><li class="chapter-item expanded "><a href="linux/introduction.html"><strong aria-hidden="true">3.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/books/1/introduction.html"><strong aria-hidden="true">3.1.</strong> 실습과 그림으로 배우는 리눅스 구조</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/books/1/chapter1.html"><strong aria-hidden="true">3.1.1.</strong> 컴퓨터 시스템의 개요</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter2.html"><strong aria-hidden="true">3.1.2.</strong> 사용자 모드로 구현되는 기능</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter3.html"><strong aria-hidden="true">3.1.3.</strong> 프로세스 관리</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter4.html"><strong aria-hidden="true">3.1.4.</strong> 프로세스 스케줄러</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Be_Software_Engineer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="프로그래밍에-대해-기록하는-곳입니다"><a class="header" href="#프로그래밍에-대해-기록하는-곳입니다">프로그래밍에 대해 기록하는 곳입니다.</a></h1>
<p>더 나은 프로그래밍을 하기 위해 노력하고 있습니다.</p>
<h2 id="기록하는-내용들"><a class="header" href="#기록하는-내용들">기록하는 내용들</a></h2>
<ul>
<li>
<h3 id="javascript"><a class="header" href="#javascript"><a href="introduction//javascript/introduction.html">Javascript</a></a></h3>
</li>
<li>
<h3 id="linux"><a class="header" href="#linux"><a href="introduction//linux/introduction.html">Linux</a></a></h3>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자바스크립트란"><a class="header" href="#자바스크립트란">자바스크립트란?</a></h1>
<ul>
<li>객체(Object) 기반의 스크립트 프로그래밍 언어
<ul>
<li>인터프리터 형식의 언어 (vs 컴파일 언어)</li>
</ul>
</li>
<li>ECMAScript 사양을 준수하는 범용 프로그래밍 언어</li>
<li>웹의 동적 동작을 구현하기 위해 제작된 언어</li>
<li>Mocha -&gt; LiveScript -&gt; Javascript로 명칭이 변경됨</li>
<li>JS 엔진위에서 수행되며, Google V8, Firefox SpiderMonkey, Edge Chakra 가 존재한다.</li>
</ul>
<h2 id="ecmascript란"><a class="header" href="#ecmascript란">ECMAScript란?</a></h2>
<ul>
<li>Ecma International ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어</li>
<li>자바스크립트를 표준화하기 위해 만들어졌으며, 액션스크립트와 J스크립트 등 다른 구현체도 포함</li>
<li>Ecma International: 정보 통신에 대한 표준을 제정하는 비영리 표준화 기구</li>
<li>ECMA-262: Ecma International에서 제정한 기술 규격의 이름으로, 범용 목적의 스크립트 언어 명세 기술</li>
<li>97년 ES1 초판, 09년 ES5, 15년 ES2015(ES6)으로 매해 6월에 버전을 갱신중이다.
<ul>
<li>15년부터 년도가 뒤에 붙는 방식으로 이름이 바뀜</li>
</ul>
</li>
</ul>
<h2 id="자바스크립트-변환-절차"><a class="header" href="#자바스크립트-변환-절차">자바스크립트 변환 절차</a></h2>
<ol>
<li>소스코드를 Parsing</li>
<li>Abstract Syntax Tree</li>
<li>lgnition Bytecode (complied code)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="변수와-상수"><a class="header" href="#변수와-상수">변수와 상수</a></h1>
<h2 id="변수"><a class="header" href="#변수">변수</a></h2>
<ul>
<li>변경 가능한 값을 저장하기 위한 공간 (Memory)</li>
</ul>
<h2 id="상수"><a class="header" href="#상수">상수</a></h2>
<ul>
<li>변경 불가능한 값을 저장하기 위한 공간</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자료형"><a class="header" href="#자료형">자료형</a></h1>
<ul>
<li>Boolean : 논리적 값 (true, false)</li>
<li>null : 존재하지 않거나 유효하지 않은 주소 표시</li>
<li>undefined : 선언 후 값을 할당하지 않은 변수</li>
<li>number : 정수, 실수 등의 숫자</li>
<li>string : 빈 문자열이나 글자들을 표현하는 문자열</li>
<li>symbol : 문자열과 함께 객체 property로 사용, ES6에 추가</li>
<li>object : 두개 이상의 복잡한 개체 저장 가능</li>
</ul>
<h2 id="원시-타입"><a class="header" href="#원시-타입">원시 타입</a></h2>
<ul>
<li>Booelan, null, undefined, number, string, symbol
<ul>
<li>null : null은 값이 비어 있다는 의미로 표현되는 자료형
<ul>
<li>존재하지 않는, 비어있는, 알 수 없는 값을 나타내는 데 사용</li>
</ul>
</li>
<li>undefined : 값이 할당되어 있지 않은 상태를 나타낼 때 사용되는 자료형</li>
<li>number: infinity, -infinity, NaN 같은 특수 숫자 값이 포함되어 있다.</li>
</ul>
</li>
</ul>
<h2 id="객체-타입"><a class="header" href="#객체-타입">객체 타입</a></h2>
<ul>
<li>object : 다수의 원시 자료형을 포함하거나 복잡한 개체를 표현할 수 있는 자료형</li>
</ul>
<h3 id="객체-복사의-문제점"><a class="header" href="#객체-복사의-문제점">객체 복사의 문제점</a></h3>
<ul>
<li>Shallow Copy vs Deep Copy
<ul>
<li>Shallow Copy : Object.assing({}, object), for, spread operator, {...object}</li>
<li>Deep Copy</li>
</ul>
</li>
</ul>
<pre><code class="language-js">Copy Object (그림과 함께 이해하기)

function copyObj(obj) {
  let result = {};

  for(let key in obj) {
    if(typeof obj[key] === &quot;object&quot;) result[key] = copyObj(obj[key]);
    else result[key] = obj[key];
  }

  return result;
}
</code></pre>
<pre><code class="language-js">JSON;

JSON.parse(JSON.stringify(object));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="호이스팅"><a class="header" href="#호이스팅">호이스팅</a></h1>
<ul>
<li>코드에 선언된 변수 및 함수를 유효한 범위의 코드 상단으로 끌어 올리는 작업</li>
<li>var의 변수 / 함수의 선언만 위로 올려지고, 값의 할당은 올려지지 않음</li>
<li>let/const 변수 선언과 함수 표현식에서는 호이스팅이 발생하지 않는다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">JSON</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope"><a class="header" href="#scope">SCOPE</a></h1>
<ul>
<li>변수 혹은 상수에 접근할 수 있는 범위</li>
<li>모듈/함수 내 코드에서 동일한 변수 사용 시 간섭을 줄이는 용도로 사용</li>
<li>Scope는 Global Scope, Local Scope의 타입으로 구분한다.
<ul>
<li>Global Scope: 전역에 선언되어 어디에서도 접근 가능</li>
<li>Local Scope(block {}, function level scope): 특정 지역에 선언되어 해당 지역 내에서만 접근 가능</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="리눅스와-관련된-내용을-정리하는-곳입니다"><a class="header" href="#리눅스와-관련된-내용을-정리하는-곳입니다">리눅스와 관련된 내용을 정리하는 곳입니다.</a></h1>
<h2 id="책-목록"><a class="header" href="#책-목록">책 목록</a></h2>
<ul>
<li>1 : <a href="linux//linux/books/1/introduction.html">실습과 그림으로 배우는 리눅스 구조</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="실습과-그림으로-배우는-리눅스-구조"><a class="header" href="#실습과-그림으로-배우는-리눅스-구조">실습과 그림으로 배우는 리눅스 구조</a></h1>
<h2 id="목차"><a class="header" href="#목차">목차</a></h2>
<ol>
<li><a href="linux/books/1/./chapter1.html">컴퓨터 시스템의 개요</a></li>
<li><a href="linux/books/1/./chapter2.html">사용자 모드로 구현되는 기능</a></li>
<li><a href="linux/books/1/./chater3.html">프로세스 관리</a></li>
<li><a href="linux/books/1/./chapter4.html">프로세스 스케줄러</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="컴퓨터-시스템의-개요"><a class="header" href="#컴퓨터-시스템의-개요">컴퓨터 시스템의 개요</a></h1>
<p>OS와 하드웨어의 관계 그리고 OS란 어떤 것인가를 간략하게 보게 된다.</p>
<h3 id="컴퓨터-시스템이-동작할-때-하드웨어에서는-다음-순서가-반복된다"><a class="header" href="#컴퓨터-시스템이-동작할-때-하드웨어에서는-다음-순서가-반복된다">컴퓨터 시스템이 동작할 때 하드웨어에서는 다음 순서가 반복된다.</a></h3>
<ol>
<li>입력 장치 혹은 네트워크 어댑터를 통해서 컴퓨터에 무언가 처리 요청이 들어온다.</li>
<li><strong>메모리에 있는 명령을 읽어 CPU에서 실행하고 그 결과 값을 다시 메모리의 다른 영역에 기록한다.</strong></li>
<li>메모리의 데이터를 하드디스크(HDD)나 SSD 등의 저장 장치에 기록 또는 네트워크를 통해 다른 컴퓨터에 전송하거나 디스플레이 등의 출력 장치를 통해 사람에게 결과 값을 보여준다.</li>
<li>1번부터 반복해서 실행한다.</li>
</ol>
<h3 id="프로그램은-크게-다음과-같은-종류로-나뉠-수-있다"><a class="header" href="#프로그램은-크게-다음과-같은-종류로-나뉠-수-있다">프로그램은 크게 다음과 같은 종류로 나뉠 수 있다.</a></h3>
<ul>
<li>어플리케이션: 사용자가 직접 사용하는 프로그램</li>
<li>미들웨어: 여러 가지 어플리케이션이 공통으로 사용하는 처리를 묶어서 애플리케이션의 실행을 도와준다. 예를 들어 웹 서버, 데이터베이스 등이 있다. 애플리케이션과 OS의 중간자 역할을 한다.</li>
<li>OS(운영체제): 하드웨어를 직접 조작하여 어플리케이션이나 미들웨어의 실행에 필요한 기능을 제공한다.
<ul>
<li>OS는 여러 가지 프로그램을 프로세스라고 하는 단위로 실행한다.</li>
</ul>
</li>
</ul>
<h3 id="리눅스와-하드웨어의-관계"><a class="header" href="#리눅스와-하드웨어의-관계">리눅스와 하드웨어의 관계</a></h3>
<p><strong>리눅스의 중요한 역할은 외부 장치(이하 디바이스)를 조작하는 일이다.</strong> </p>
<p>리눅스 같은 OS가 없으면 여러 개의 프로세스가 각각 디바이스를 조작하는 코드를 작성해야 한다.
리눅스는 디바이스 드라이버라고 하는 프로그램을 통해 디바이스를 다룬다.</p>
<p>CPU에는 커널 모드와 사용자 모드라고 하는 두 가지 모드가 있으며 커널 모드로 동작할 때만 디바이스에 접근할 수 있다.
디바이스 드라이버는 커널 모드로 동작하고 프로세스는 사용자 모드로 동작한다.</p>
<p><strong>커널모드에서 동작하는 것들</strong></p>
<ul>
<li>프로세스 관리 시스템</li>
<li>프로세스 스케줄링</li>
<li>메모리 관리 시스템</li>
</ul>
<p>OS의 핵심 부분이 되는 처리를 모아 담당하는 프로그램을 <strong>커널</strong>이라고 부른다.
프로세스가 디바이스 드라이버를 포함한 커널이 제공하는 기능을 사용하려 할 때는 <strong>시스템 콜</strong>이라고 하는 특수한 처리를 통해 커널에 요청한다.
커널은 시스템에 탑재된 CPU나 메모리 등의 리소스를 관리하고 있으며 리소스의 일부를 시스템에 존재하는 각 프로세스에 적절히 분배한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="사용자-모드로-구현되는-기능"><a class="header" href="#사용자-모드로-구현되는-기능">사용자 모드로 구현되는 기능</a></h1>
<p>사용자 모드는 라이브러리 형태인 것도 있고 단독 프로그램으로 동작하는 것도 있다.</p>
<h2 id="시스템-콜"><a class="header" href="#시스템-콜">시스템 콜</a></h2>
<ul>
<li>프로세스는 프로세스의 생성이나 하드웨어의 조작 등 커널의 도움이 필요할 경우 시스템 콜을 통해 커널에 처리를 요청합니다.</li>
</ul>
<h3 id="시스템-콜의-종류"><a class="header" href="#시스템-콜의-종류">시스템 콜의 종류</a></h3>
<ul>
<li>프로세스 생성, 삭제</li>
<li>메모리 확보, 해제</li>
<li>프로세스 간 통신 (IPC)</li>
<li>네트워크</li>
<li>파일시스템 다루기</li>
<li>파일 다루기 (디바이스 접근)</li>
</ul>
<h3 id="cpu의-모드-변경"><a class="header" href="#cpu의-모드-변경">CPU의 모드 변경</a></h3>
<ul>
<li>시스템 콜은 CPU의 특수한 명령을 실행해야만 호출된다. 프로세스는 보통 사용자 모드로 실행되고 있지만 커널에 처리를 요청하고자 시스템 콜을 호출하면 CPU에서는 인터럽트 이벤트가 발생한다.</li>
<li>인터럽트 이벤트가 발생하면 CPU는 사용자 모드에서 커널 모드로 변경되며 요청한 내용을 처리하기 위해 커널이 동작하기 시작한다.</li>
<li>요청한 내용 처리가 끝나면 커널 내의 시스템 콜 처리가 종료된다. 그리고 다시 사용자 모드로 돌아가 프로세스의 동작을 계속 진행한다.</li>
</ul>
<p>커널은 프로세스가 요청한 내용을 처리하기 전에 프로세스의 요구가 유효한지 확인한다.
요구 사항이 맞지 않는다면 커널은 시스템 콜을 실패했다고 처리한다.
(예를 들어 시스템의 메모리 용량 이상의 메모리를 요구하는 것 등)</p>
<h3 id="시스템-콜-호출의-동작-순서"><a class="header" href="#시스템-콜-호출의-동작-순서">시스템 콜 호출의 동작 순서</a></h3>
<pre><code class="language-c">
$ cc -o hello hello.c
$ cc -o hello hello.py

/* 
cc 시스템 콜 로그를 출력하는 커맨드
-o strace 출력을 별도로 저장하기 위한 output 옵션
*/

</code></pre>
<p>어플리케이션 코드 작성을 위한 프로그램 언어가 무엇이든 상관없이 프로그램이 커널에 요청을 할 때 사용되는 시스템 콜을 호출하는 코드는 동일하다는 것을 알 수 있다.</p>
<p>프로세스가 사용자 모드와 커널 모드 중 어느 쪽에서 실행되고 있는 지의 비율은 'sar' 명령어로 확인할 수 있다.</p>
<pre><code>
$ sar -P ALL 1 //각 CPU 코어가 어떤 종류의 처리를 실행하고 있는 지를 1초 단위로 측정한다.

</code></pre>
<h3 id="시스템-콜-명령어"><a class="header" href="#시스템-콜-명령어">시스템 콜 명령어</a></h3>
<ul>
<li>getppid() : 부모 프로세스의 프로세스 ID를 얻는 명령어 (get parent process id)</li>
<li>kill <code>process id</code>: 프로세스를 종료</li>
<li>strace -T : 각종 시스템 콜 처리에 걸린 시간을 마이크로초 단위로 정밀하게 측정할 수 있다.</li>
</ul>
<h2 id="시스템-콜의-wrapper-함수--시스템-콜을-호출하는-일만-하는-함수"><a class="header" href="#시스템-콜의-wrapper-함수--시스템-콜을-호출하는-일만-하는-함수">시스템 콜의 Wrapper 함수 = 시스템 콜을 호출하는 일만 하는 함수</a></h2>
<p>리눅스에는 프로그램의 작성을 도와주기 위해 프로세스 대부분에 필요한 여러 라이브러리 함수가 있다.
시스템 콜은 보통의 함수 호출과는 다르게 C언어 등의 고급언어에서는 직접 호출이 불가능하다.
아키텍처에 의존하는 어셈블리 코드를 사용해 호출할 필요가 있다.</p>
<p>이러한 문제를 해결하기 위해서 OS는 내부적으로 시스템 콜을 호출하는 일만 하는 함수를 제공하는 데 이를 시스템 콜 wrapper라고 한다.</p>
<h2 id="표준-c-라이브러리"><a class="header" href="#표준-c-라이브러리">표준 C 라이브러리</a></h2>
<p>C 언어에는 ISO에 의해 정해진 표준 라이브러리가 있다.
리눅스에도 이 표준 C라이브러리가 제공되고 있다.
보통은 GNU 프로젝트가 제공하는 glibc를 표준 C라이브러리로 사용한다.
대부분의 C 프로그램은 glibc를 링크하고 있다.</p>
<p>glibc는 시스템 콜의 wrapper 함수를 포함한다.
또한 POSIX 규격에 의해 정의된 함수도 제공한다.</p>
<p>POSIX: 유닉스 계열의 OS가 갖추어야 할 각종 기능을 정해둔 규격
GNU 프로젝트: 유닉스와 호환되는 자유 소프트웨어를 개발하는 프로젝트</p>
<ul>
<li>프로그램을 어떠한 목적으로도 시행할 수 있는 자유</li>
<li>프로그램이 어떻게 동작하는지 학습하고 자신의 필요에 맞게 개박할 수 있는 자유, 이를 위해서는 소스코드에 대한 접근이 전제되어야 한다.</li>
<li>이웃을 돕도록 복제물을 재배포할 수 있는 자유</li>
<li>프로그램을 개선할 수 있는 자유와 개선된 이점을 공동체 전체가 누리도록 발표할 수 있는 자유, 이를 위해서도 역시 소스코드에 대한 접근이 전제되어야 한다.
ISO: 국제 표준화 기구</li>
</ul>
<pre><code>
$ ldd /bin/echo

ldd: 프로그램이 어떠한 라이브러리를 링크하고 있는 지 알 수 있는 명령어

</code></pre>
<h2 id="os가-제공하는-프로그램"><a class="header" href="#os가-제공하는-프로그램">OS가 제공하는 프로그램</a></h2>
<p>OS가 제공하는 프로그램은 OS가 제공하는 라이브러리와 마찬가지로 대부분의 프로그램이 필요하다
OS의 동작을 변경시키는 프로그램도 OS의 일부로써 제공된다.</p>
<ul>
<li>시스템 초기화: init</li>
<li>OS의 동작을 바꿈: sysctl, nice, sync</li>
<li>파일 관련: touch, mkdir</li>
<li>텍스트 데이터 가공: grep, sort, uniq</li>
<li>성능 측정: sar, iostat</li>
<li>컴파일러: gcc</li>
<li>스크립트 언어 실행 환경: perl, python, ruby</li>
<li>셀: bash</li>
<li>윈도우 시스템: X</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로세스-관리"><a class="header" href="#프로세스-관리">프로세스 관리</a></h1>
<h2 id="프로세스-생성의-목적"><a class="header" href="#프로세스-생성의-목적">프로세스 생성의 목적</a></h2>
<p>리눅스에서는 두 가지 목적으로 프로세스를 생성한다.</p>
<ol>
<li>같은 프로그램의 처리를 여러 개의 프로세스가 나눠서 처리한다. 예를 들어 웹 서버처럼 리퀘스트가 여러 개 들어왔을 때 동시에 처리해야 하는 경우</li>
<li>전혀 다른 프로그램을 생성합니다. 예를 들어 bash로부터 각종 프로그램을 새로 생성하는 경우</li>
</ol>
<h3 id="fork-함수"><a class="header" href="#fork-함수">fork() 함수</a></h3>
<p>목적1을 수행하는 함수이다.
fork 함수를 실행하면 실행한 프로세스와 함께 새로운 프로세스가 1개가 커널 메모리로부터 생성된다.
생성 전의 프로세스를 부모 프로세스(parent process), 새롭게 생성된 프로세스를 자식 프로세스(child process)라고 부릅니다.</p>
<ol>
<li>자식 프로세스용 메모리 영역을 작성하고 거기에 부모 프로세스의 메모리를 복사한다</li>
<li>fork 함수의 리턴 값이 각기 다른 것을 이용하며 부모 프로세스와 자식 프로세스가 서로 다른 코드를 실행하도록 분기한다.</li>
</ol>
<h3 id="execve-함수"><a class="header" href="#execve-함수">execve() 함수</a></h3>
<p>전혀 다른 프로그램을 생성할 때에는 execve() 함수를 사용한다.</p>
<ol>
<li>실행 파일을 읽은 다음 프로세스의 메모리 맵에 필요한 정보를 읽어들인다.</li>
<li>현재 프로세스의 메모리를 새로운 프로세스의 데이터로 덮어쓴다.</li>
<li>새로운 프로세스의 첫 번째 명령부터 실행한다.</li>
</ol>
<p>즉, 전혀 다른 프로그램을 생성하는 경우 프로세스의 수가 증가하는 것이 아니라 기존의 프로세스를 별도의 프로세스로 변경하는 방식으로 수행된다.
리눅스의 실행 파일은 실제로는 위에서 설명한 것 같은 단순한 것이 아니라 'ELF Executable and Linkable Format'라는 형식을 사용한다.
ELF 형식의 각종 정보는 'readelf' 명령어로 자세히 볼 수 있다.</p>
<pre><code>
$ readelf -h /bin/sleep

# readelf : ELF 형식의 각종 정보를 출력하는 명령어

</code></pre>
<h3 id="fork-and-exec-방식"><a class="header" href="#fork-and-exec-방식">fork and exec 방식</a></h3>
<p>bash 에서 echo를 실행하는 과정</p>
<ol>
<li>bash 메모리를 기준으로 fork()를 통해 자식 프로세스를 생성</li>
<li>자식 프로세스를 다른 프로그램으로 대체하기 위해 exec() 실행</li>
<li>echo의 메모리가 되어 echo 프로그램을 실행</li>
</ol>
<h3 id="_exit"><a class="header" href="#_exit">_exit()</a></h3>
<p>프로그램 종료는 '_exit()'함수를 사용한다.
( 내부에서는 exit_group() 시스템 콜을 호출한다 )
이 함수를 이용하면 할당된 메모리를 전부 회수한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로세스-스케줄러"><a class="header" href="#프로세스-스케줄러">프로세스 스케줄러</a></h1>
<p>리눅스 커널에는 '프로세스 스케줄러' 기능이 있는데 이 기능은 여러 개의 프로세스를 동시에 동작시킨다. 정확히는 동시에 동작시키는 것처럼 보이게 한다.</p>
<ul>
<li>
<p>하나의 CPU는 동시에 하나의 프로세스만 처리할 수 있다.</p>
</li>
<li>
<p>하나의 CPU에 여러 개의 프로세스를 실행해야 할 때는 각 프로세스를 적절한 시간으로 쪼개서(타임 슬라이스) 번갈아 처리한다.</p>
</li>
<li>
<p>프로세스를 종료시킬 때까지의 경과 시간은 프로세스 수에 비례하여 증가한다.</p>
</li>
<li>
<p>각 프로세스는 대략 같은 타임 슬라이스를 가진다.</p>
</li>
</ul>
<h2 id="라운드-로빈"><a class="header" href="#라운드-로빈">라운드 로빈</a></h2>
<ul>
<li>프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(타임 퀀텀)로 CPU를 할당하는 방식</li>
</ul>
<h2 id="컨텍스트-스위치"><a class="header" href="#컨텍스트-스위치">컨텍스트 스위치</a></h2>
<p>논리 CPU상에서 동작하는 프로세스가 바뀌는 것을 '컨텍스트 스위치'라고 부른다.</p>
<h2 id="프로세스의-상태"><a class="header" href="#프로세스의-상태">프로세스의 상태</a></h2>
<p>프로세스의 상태는 다음과 같다.</p>
<ul>
<li>실행 상태: 현재 논리 CPU를 사용하고 있다</li>
<li>실행 대기 상태: CPU 시간이 할당되기를 기다리고 있다.</li>
<li>슬립 상태: 이벤트가 발생하기를 기다리고 있으며 이벤트 발생까지는 CPU시간을 사용하지 않는다.</li>
<li>좀비 상태: 프로세스가 종료한 뒤 부모 프로세스가 종료 상태를 인식할 때까지 기다리고 있다.</li>
</ul>
<h2 id="idle-상태"><a class="header" href="#idle-상태">idle 상태</a></h2>
<ul>
<li>'아무것도 하지 않는' 특수한 프로세스가 동작한다.</li>
<li>시스템 전체가 CPU 시간을 거의 사용하지 않을 때</li>
</ul>
<h2 id="스루풋과-레이턴시"><a class="header" href="#스루풋과-레이턴시">스루풋과 레이턴시</a></h2>
<p>각종 성능지표인 스루풋과 레이턴시에 대해 정리한다.</p>
<ul>
<li>스루풋: 단위 시간당 처리된 일의 양이며 높을수록 좋다. 
( 완료한 프로세스의 수 / 경과 시간 )</li>
<li>레이턴시: 각각의 처리가 시작부터 종료까지의 경과된 시간으로 짧을수록 좋다. 
( 처리 종료 시간 - 처리 시작 시간 )</li>
</ul>
<h2 id="실제-시스템"><a class="header" href="#실제-시스템">실제 시스템</a></h2>
<p>실제 시스템에 돌아가는 논리 CPU는 다음과 같은 상태를 정신 없이 오고 간다.</p>
<ul>
<li>idle 상태: 논리 CPU가 쉬고 있기 때문에 스루풋이 떨어지는 경향이 있다.</li>
<li>프로세스가 동작 중: 실행 대기의 프로세스가 없기 때문에 이상적인 상태이다. 그러나 이러한 상태는 다음의 프로세스가 실행 가능한 상태가 되면, 2개의 프로세스의 레이턴시가 양쪽 다 길어진다.</li>
<li>프로세스가 대기 중: 실행 대기 프로세스가 있다. 스루풋은 높지만 레이턴시가 길어지는 경향이 있다.</li>
</ul>
<h2 id="논리-cpu가-여러-개일-때-스케줄링"><a class="header" href="#논리-cpu가-여러-개일-때-스케줄링">논리 CPU가 여러 개일 때 스케줄링</a></h2>
<p>논리 CPU가 여러 개일 때 스케줄링은 어떻게 될까? 이 때는 로드밸런서 혹은 글로벌 스케줄러라는 기능이 동작한다. 로드밸런서란 여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할을 한다.
프로세스를 할당받은 각 논리 CPU안에서 1개의 논리 CPU가 있을 떄와 마찬가지로 각 프로세스에 공평하게 CPU 시간을 분배한다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
