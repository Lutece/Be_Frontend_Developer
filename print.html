<!DOCTYPE HTML>
<html lang="ko" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Be_Software_Engineer</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="java/introduction.html"><strong aria-hidden="true">2.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/pocu/1.html"><strong aria-hidden="true">2.1.</strong> pocu</a></li></ol></li><li class="chapter-item expanded "><a href="javascript/introduction.html"><strong aria-hidden="true">3.</strong> Javascript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="javascript/var.html"><strong aria-hidden="true">3.1.</strong> var</a></li><li class="chapter-item expanded "><a href="javascript/data.html"><strong aria-hidden="true">3.2.</strong> data</a></li><li class="chapter-item expanded "><a href="javascript/hoisting.html"><strong aria-hidden="true">3.3.</strong> hosting</a></li><li class="chapter-item expanded "><a href="javascript/json.html"><strong aria-hidden="true">3.4.</strong> json</a></li><li class="chapter-item expanded "><a href="javascript/scope.html"><strong aria-hidden="true">3.5.</strong> scope</a></li></ol></li><li class="chapter-item expanded "><a href="linux/introduction.html"><strong aria-hidden="true">4.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/books/1/introduction.html"><strong aria-hidden="true">4.1.</strong> 실습과 그림으로 배우는 리눅스 구조</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux/books/1/chapter1.html"><strong aria-hidden="true">4.1.1.</strong> 컴퓨터 시스템의 개요</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter2.html"><strong aria-hidden="true">4.1.2.</strong> 사용자 모드로 구현되는 기능</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter3.html"><strong aria-hidden="true">4.1.3.</strong> 프로세스 관리</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter4.html"><strong aria-hidden="true">4.1.4.</strong> 프로세스 스케줄러</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter5.html"><strong aria-hidden="true">4.1.5.</strong> 메모리 관리</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter6.html"><strong aria-hidden="true">4.1.6.</strong> 메모리 계층</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter7.html"><strong aria-hidden="true">4.1.7.</strong> 파일 시스템</a></li><li class="chapter-item expanded "><a href="linux/books/1/chapter8.html"><strong aria-hidden="true">4.1.8.</strong> 저장 장치</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Be_Software_Engineer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="프로그래밍에-대해-기록하는-곳입니다"><a class="header" href="#프로그래밍에-대해-기록하는-곳입니다">프로그래밍에 대해 기록하는 곳입니다.</a></h1>
<h2 id="더-나은-개발자가-되기-위해"><a class="header" href="#더-나은-개발자가-되기-위해">더 나은 개발자가 되기 위해...</a></h2>
<ul>
<li><a href="introduction//javascript/introduction.html">Javascript</a></li>
<li><a href="introduction//java/book/1/basic.html">Java</a></li>
<li><a href="introduction//linux/introduction.html">Linux</a></li>
<li><a href="introduction//DT_and_AL/introduction.html">Data Structure and Algorithm</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자바"><a class="header" href="#자바">자바</a></h1>
<p><a href="java/./pocu/1.html">POCU</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="개체지향-프로그래밍oop와-개체지향-분석-및-설계-ooad"><a class="header" href="#개체지향-프로그래밍oop와-개체지향-분석-및-설계-ooad">개체지향 프로그래밍(OOP)와 개체지향 분석 및 설계 (OOAD)</a></h1>
<p>개체지향 프로그래밍은 객관성이 떨어지는 부분들이 있다.</p>
<p>그래서 주관적인 관점으로 바라보게되는 경우가 많다.</p>
<h2 id="정리할-내용들"><a class="header" href="#정리할-내용들">정리할 내용들</a></h2>
<ul>
<li>Java 언어 문법</li>
<li>개체지향 프로그래밍 특성</li>
<li>올바른 개체지향 설계법</li>
<li>개체지향에 대한 다양한 의견들</li>
</ul>
<h3 id="다수설소수설을-알아야-하는-이유"><a class="header" href="#다수설소수설을-알아야-하는-이유">다수설/소수설을 알아야 하는 이유</a></h3>
<p>Java</p>
<ul>
<li>현업에 있는 개발자들이 만들어간 언어</li>
</ul>
<p>개체지향(OO)은 업계에 제대로 몸담지 않은 사람들도 다양한 의견을 내던 분야이다. 
그 이전에 기계어와 성격이 가까운 언어들은 코드가 해석되는 방식이 어느정도 정해져있기 때문에 OO처럼 다양한 의견이 나오기 쉽지 않았다.</p>
<h3 id="좋은-프로그래밍-언어란"><a class="header" href="#좋은-프로그래밍-언어란">좋은 프로그래밍 언어란?</a></h3>
<ul>
<li>프로그래머의 효율을 높이는 언어</li>
<li>프로그래머의 실수를 줄이는 언어</li>
</ul>
<h2 id="java-라는-도구란"><a class="header" href="#java-라는-도구란">Java 라는 도구란?</a></h2>
<ul>
<li>1991년 첫 등장</li>
<li>썬 마이크로시스템즈의 제임스 고슬링과 동료들이 개발함</li>
</ul>
<h3 id="java의-개발-배경"><a class="header" href="#java의-개발-배경">Java의 개발 배경</a></h3>
<ul>
<li>기존 언어는 각 플랫폼마다 컴파일을 해야 했음 그래서
한 번만 빌드하면 어떤 플랫폼에서든 작동하는 언어를 만들게 됨</li>
<li>갑자기 고속 성장하던 인터넷에 맞춰 그쪽으로 방향을 바꾸어 대중화에 성공함</li>
</ul>
<h3 id="가장-많이-쓰이는-매니지드-언어"><a class="header" href="#가장-많이-쓰이는-매니지드-언어">가장 많이 쓰이는 매니지드 언어</a></h3>
<ul>
<li>매니지드 언어이기에 메모리 관리를 덜 신경 써도 됨</li>
<li>기계와 아주 가깝지 않은 개념을 코드로 옮기기에 사용하기 적합</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자바스크립트란"><a class="header" href="#자바스크립트란">자바스크립트란?</a></h1>
<ul>
<li>객체(Object) 기반의 스크립트 프로그래밍 언어
<ul>
<li>인터프리터 형식의 언어 (vs 컴파일 언어)</li>
</ul>
</li>
<li>ECMAScript 사양을 준수하는 범용 프로그래밍 언어</li>
<li>웹의 동적 동작을 구현하기 위해 제작된 언어</li>
<li>Mocha -&gt; LiveScript -&gt; Javascript로 명칭이 변경됨</li>
<li>JS 엔진위에서 수행되며, Google V8, Firefox SpiderMonkey, Edge Chakra 가 존재한다.</li>
</ul>
<h2 id="ecmascript란"><a class="header" href="#ecmascript란">ECMAScript란?</a></h2>
<ul>
<li>Ecma International ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어</li>
<li>자바스크립트를 표준화하기 위해 만들어졌으며, 액션스크립트와 J스크립트 등 다른 구현체도 포함</li>
<li>Ecma International: 정보 통신에 대한 표준을 제정하는 비영리 표준화 기구</li>
<li>ECMA-262: Ecma International에서 제정한 기술 규격의 이름으로, 범용 목적의 스크립트 언어 명세 기술</li>
<li>97년 ES1 초판, 09년 ES5, 15년 ES2015(ES6)으로 매해 6월에 버전을 갱신중이다.
<ul>
<li>15년부터 년도가 뒤에 붙는 방식으로 이름이 바뀜</li>
</ul>
</li>
</ul>
<h2 id="자바스크립트-변환-절차"><a class="header" href="#자바스크립트-변환-절차">자바스크립트 변환 절차</a></h2>
<ol>
<li>소스코드를 Parsing</li>
<li>Abstract Syntax Tree</li>
<li>lgnition Bytecode (complied code)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="변수와-상수"><a class="header" href="#변수와-상수">변수와 상수</a></h1>
<h2 id="변수"><a class="header" href="#변수">변수</a></h2>
<ul>
<li>변경 가능한 값을 저장하기 위한 공간 (Memory)</li>
</ul>
<h2 id="상수"><a class="header" href="#상수">상수</a></h2>
<ul>
<li>변경 불가능한 값을 저장하기 위한 공간</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자료형"><a class="header" href="#자료형">자료형</a></h1>
<ul>
<li>Boolean : 논리적 값 (true, false)</li>
<li>null : 존재하지 않거나 유효하지 않은 주소 표시</li>
<li>undefined : 선언 후 값을 할당하지 않은 변수</li>
<li>number : 정수, 실수 등의 숫자</li>
<li>string : 빈 문자열이나 글자들을 표현하는 문자열</li>
<li>symbol : 문자열과 함께 객체 property로 사용, ES6에 추가</li>
<li>object : 두개 이상의 복잡한 개체 저장 가능</li>
</ul>
<h2 id="원시-타입"><a class="header" href="#원시-타입">원시 타입</a></h2>
<ul>
<li>Booelan, null, undefined, number, string, symbol
<ul>
<li>null : null은 값이 비어 있다는 의미로 표현되는 자료형
<ul>
<li>존재하지 않는, 비어있는, 알 수 없는 값을 나타내는 데 사용</li>
</ul>
</li>
<li>undefined : 값이 할당되어 있지 않은 상태를 나타낼 때 사용되는 자료형</li>
<li>number: infinity, -infinity, NaN 같은 특수 숫자 값이 포함되어 있다.</li>
</ul>
</li>
</ul>
<h2 id="객체-타입"><a class="header" href="#객체-타입">객체 타입</a></h2>
<ul>
<li>object : 다수의 원시 자료형을 포함하거나 복잡한 개체를 표현할 수 있는 자료형</li>
</ul>
<h3 id="객체-복사의-문제점"><a class="header" href="#객체-복사의-문제점">객체 복사의 문제점</a></h3>
<ul>
<li>Shallow Copy vs Deep Copy
<ul>
<li>Shallow Copy : Object.assing({}, object), for, spread operator, {...object}</li>
<li>Deep Copy</li>
</ul>
</li>
</ul>
<pre><code class="language-js">Copy Object (그림과 함께 이해하기)

function copyObj(obj) {
  let result = {};

  for(let key in obj) {
    if(typeof obj[key] === &quot;object&quot;) result[key] = copyObj(obj[key]);
    else result[key] = obj[key];
  }

  return result;
}
</code></pre>
<pre><code class="language-js">JSON;

JSON.parse(JSON.stringify(object));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="호이스팅"><a class="header" href="#호이스팅">호이스팅</a></h1>
<ul>
<li>코드에 선언된 변수 및 함수를 유효한 범위의 코드 상단으로 끌어 올리는 작업</li>
<li>var의 변수 / 함수의 선언만 위로 올려지고, 값의 할당은 올려지지 않음</li>
<li>let/const 변수 선언과 함수 표현식에서는 호이스팅이 발생하지 않는다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">JSON</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope"><a class="header" href="#scope">SCOPE</a></h1>
<ul>
<li>변수 혹은 상수에 접근할 수 있는 범위</li>
<li>모듈/함수 내 코드에서 동일한 변수 사용 시 간섭을 줄이는 용도로 사용</li>
<li>Scope는 Global Scope, Local Scope의 타입으로 구분한다.
<ul>
<li>Global Scope: 전역에 선언되어 어디에서도 접근 가능</li>
<li>Local Scope(block {}, function level scope): 특정 지역에 선언되어 해당 지역 내에서만 접근 가능</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="리눅스와-관련된-내용을-정리하는-곳입니다"><a class="header" href="#리눅스와-관련된-내용을-정리하는-곳입니다">리눅스와 관련된 내용을 정리하는 곳입니다.</a></h1>
<h2 id="책-목록"><a class="header" href="#책-목록">책 목록</a></h2>
<ul>
<li>1 : <a href="linux//linux/books/1/introduction.html">실습과 그림으로 배우는 리눅스 구조</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="실습과-그림으로-배우는-리눅스-구조"><a class="header" href="#실습과-그림으로-배우는-리눅스-구조">실습과 그림으로 배우는 리눅스 구조</a></h1>
<h2 id="목차"><a class="header" href="#목차">목차</a></h2>
<ol>
<li><a href="linux/books/1/./chapter1.html">컴퓨터 시스템의 개요</a></li>
<li><a href="linux/books/1/./chapter2.html">사용자 모드로 구현되는 기능</a></li>
<li><a href="linux/books/1/./chater3.html">프로세스 관리</a></li>
<li><a href="linux/books/1/./chapter4.html">프로세스 스케줄러</a></li>
<li><a href="linux/books/1/./chapter5.html">메모리 관리</a></li>
<li><a href="linux/books/1/./chapter6.html">메모리 계층</a></li>
<li><a href="linux/books/1/./chapter7.html">파일 시스템</a></li>
<li><a href="linux/books/1/./chapter8.html">저장 장치</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="컴퓨터-시스템의-개요"><a class="header" href="#컴퓨터-시스템의-개요">컴퓨터 시스템의 개요</a></h1>
<p>OS와 하드웨어의 관계 그리고 OS란 어떤 것인가를 간략하게 보게 된다.</p>
<h3 id="컴퓨터-시스템이-동작할-때-하드웨어에서는-다음-순서가-반복된다"><a class="header" href="#컴퓨터-시스템이-동작할-때-하드웨어에서는-다음-순서가-반복된다">컴퓨터 시스템이 동작할 때 하드웨어에서는 다음 순서가 반복된다.</a></h3>
<ol>
<li>입력 장치 혹은 네트워크 어댑터를 통해서 컴퓨터에 무언가 처리 요청이 들어온다.</li>
<li><strong>메모리에 있는 명령을 읽어 CPU에서 실행하고 그 결과 값을 다시 메모리의 다른 영역에 기록한다.</strong></li>
<li>메모리의 데이터를 하드디스크(HDD)나 SSD 등의 저장 장치에 기록 또는 네트워크를 통해 다른 컴퓨터에 전송하거나 디스플레이 등의 출력 장치를 통해 사람에게 결과 값을 보여준다.</li>
<li>1번부터 반복해서 실행한다.</li>
</ol>
<h3 id="프로그램은-크게-다음과-같은-종류로-나뉠-수-있다"><a class="header" href="#프로그램은-크게-다음과-같은-종류로-나뉠-수-있다">프로그램은 크게 다음과 같은 종류로 나뉠 수 있다.</a></h3>
<ul>
<li>어플리케이션: 사용자가 직접 사용하는 프로그램</li>
<li>미들웨어: 여러 가지 어플리케이션이 공통으로 사용하는 처리를 묶어서 애플리케이션의 실행을 도와준다. 예를 들어 웹 서버, 데이터베이스 등이 있다. 애플리케이션과 OS의 중간자 역할을 한다.</li>
<li>OS(운영체제): 하드웨어를 직접 조작하여 어플리케이션이나 미들웨어의 실행에 필요한 기능을 제공한다.
<ul>
<li>OS는 여러 가지 프로그램을 프로세스라고 하는 단위로 실행한다.</li>
</ul>
</li>
</ul>
<h3 id="리눅스와-하드웨어의-관계"><a class="header" href="#리눅스와-하드웨어의-관계">리눅스와 하드웨어의 관계</a></h3>
<p><strong>리눅스의 중요한 역할은 외부 장치(이하 디바이스)를 조작하는 일이다.</strong> </p>
<p>리눅스 같은 OS가 없으면 여러 개의 프로세스가 각각 디바이스를 조작하는 코드를 작성해야 한다.
리눅스는 디바이스 드라이버라고 하는 프로그램을 통해 디바이스를 다룬다.</p>
<p>CPU에는 커널 모드와 사용자 모드라고 하는 두 가지 모드가 있으며 커널 모드로 동작할 때만 디바이스에 접근할 수 있다.
디바이스 드라이버는 커널 모드로 동작하고 프로세스는 사용자 모드로 동작한다.</p>
<p><strong>커널모드에서 동작하는 것들</strong></p>
<ul>
<li>프로세스 관리 시스템</li>
<li>프로세스 스케줄링</li>
<li>메모리 관리 시스템</li>
</ul>
<p>OS의 핵심 부분이 되는 처리를 모아 담당하는 프로그램을 <strong>커널</strong>이라고 부른다.
프로세스가 디바이스 드라이버를 포함한 커널이 제공하는 기능을 사용하려 할 때는 <strong>시스템 콜</strong>이라고 하는 특수한 처리를 통해 커널에 요청한다.
커널은 시스템에 탑재된 CPU나 메모리 등의 리소스를 관리하고 있으며 리소스의 일부를 시스템에 존재하는 각 프로세스에 적절히 분배한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="사용자-모드로-구현되는-기능"><a class="header" href="#사용자-모드로-구현되는-기능">사용자 모드로 구현되는 기능</a></h1>
<p>사용자 모드는 라이브러리 형태인 것도 있고 단독 프로그램으로 동작하는 것도 있다.</p>
<h2 id="시스템-콜"><a class="header" href="#시스템-콜">시스템 콜</a></h2>
<ul>
<li>프로세스는 프로세스의 생성이나 하드웨어의 조작 등 커널의 도움이 필요할 경우 시스템 콜을 통해 커널에 처리를 요청합니다.</li>
</ul>
<h3 id="시스템-콜의-종류"><a class="header" href="#시스템-콜의-종류">시스템 콜의 종류</a></h3>
<ul>
<li>프로세스 생성, 삭제</li>
<li>메모리 확보, 해제</li>
<li>프로세스 간 통신 (IPC)</li>
<li>네트워크</li>
<li>파일시스템 다루기</li>
<li>파일 다루기 (디바이스 접근)</li>
</ul>
<h3 id="cpu의-모드-변경"><a class="header" href="#cpu의-모드-변경">CPU의 모드 변경</a></h3>
<ul>
<li>시스템 콜은 CPU의 특수한 명령을 실행해야만 호출된다. 프로세스는 보통 사용자 모드로 실행되고 있지만 커널에 처리를 요청하고자 시스템 콜을 호출하면 CPU에서는 인터럽트 이벤트가 발생한다.</li>
<li>인터럽트 이벤트가 발생하면 CPU는 사용자 모드에서 커널 모드로 변경되며 요청한 내용을 처리하기 위해 커널이 동작하기 시작한다.</li>
<li>요청한 내용 처리가 끝나면 커널 내의 시스템 콜 처리가 종료된다. 그리고 다시 사용자 모드로 돌아가 프로세스의 동작을 계속 진행한다.</li>
</ul>
<p>커널은 프로세스가 요청한 내용을 처리하기 전에 프로세스의 요구가 유효한지 확인한다.
요구 사항이 맞지 않는다면 커널은 시스템 콜을 실패했다고 처리한다.
(예를 들어 시스템의 메모리 용량 이상의 메모리를 요구하는 것 등)</p>
<h3 id="시스템-콜-호출의-동작-순서"><a class="header" href="#시스템-콜-호출의-동작-순서">시스템 콜 호출의 동작 순서</a></h3>
<pre><code class="language-c">
$ cc -o hello hello.c
$ cc -o hello hello.py

/* 
cc 시스템 콜 로그를 출력하는 커맨드
-o strace 출력을 별도로 저장하기 위한 output 옵션
*/

</code></pre>
<p>어플리케이션 코드 작성을 위한 프로그램 언어가 무엇이든 상관없이 프로그램이 커널에 요청을 할 때 사용되는 시스템 콜을 호출하는 코드는 동일하다는 것을 알 수 있다.</p>
<p>프로세스가 사용자 모드와 커널 모드 중 어느 쪽에서 실행되고 있는 지의 비율은 'sar' 명령어로 확인할 수 있다.</p>
<pre><code>
$ sar -P ALL 1 //각 CPU 코어가 어떤 종류의 처리를 실행하고 있는 지를 1초 단위로 측정한다.

</code></pre>
<h3 id="시스템-콜-명령어"><a class="header" href="#시스템-콜-명령어">시스템 콜 명령어</a></h3>
<ul>
<li>getppid() : 부모 프로세스의 프로세스 ID를 얻는 명령어 (get parent process id)</li>
<li>kill <code>process id</code>: 프로세스를 종료</li>
<li>strace -T : 각종 시스템 콜 처리에 걸린 시간을 마이크로초 단위로 정밀하게 측정할 수 있다.</li>
</ul>
<h2 id="시스템-콜의-wrapper-함수--시스템-콜을-호출하는-일만-하는-함수"><a class="header" href="#시스템-콜의-wrapper-함수--시스템-콜을-호출하는-일만-하는-함수">시스템 콜의 Wrapper 함수 = 시스템 콜을 호출하는 일만 하는 함수</a></h2>
<p>리눅스에는 프로그램의 작성을 도와주기 위해 프로세스 대부분에 필요한 여러 라이브러리 함수가 있다.
시스템 콜은 보통의 함수 호출과는 다르게 C언어 등의 고급언어에서는 직접 호출이 불가능하다.
아키텍처에 의존하는 어셈블리 코드를 사용해 호출할 필요가 있다.</p>
<p>이러한 문제를 해결하기 위해서 OS는 내부적으로 시스템 콜을 호출하는 일만 하는 함수를 제공하는 데 이를 시스템 콜 wrapper라고 한다.</p>
<h2 id="표준-c-라이브러리"><a class="header" href="#표준-c-라이브러리">표준 C 라이브러리</a></h2>
<p>C 언어에는 ISO에 의해 정해진 표준 라이브러리가 있다.
리눅스에도 이 표준 C라이브러리가 제공되고 있다.
보통은 GNU 프로젝트가 제공하는 glibc를 표준 C라이브러리로 사용한다.
대부분의 C 프로그램은 glibc를 링크하고 있다.</p>
<p>glibc는 시스템 콜의 wrapper 함수를 포함한다.
또한 POSIX 규격에 의해 정의된 함수도 제공한다.</p>
<p>POSIX: 유닉스 계열의 OS가 갖추어야 할 각종 기능을 정해둔 규격
GNU 프로젝트: 유닉스와 호환되는 자유 소프트웨어를 개발하는 프로젝트</p>
<ul>
<li>프로그램을 어떠한 목적으로도 시행할 수 있는 자유</li>
<li>프로그램이 어떻게 동작하는지 학습하고 자신의 필요에 맞게 개박할 수 있는 자유, 이를 위해서는 소스코드에 대한 접근이 전제되어야 한다.</li>
<li>이웃을 돕도록 복제물을 재배포할 수 있는 자유</li>
<li>프로그램을 개선할 수 있는 자유와 개선된 이점을 공동체 전체가 누리도록 발표할 수 있는 자유, 이를 위해서도 역시 소스코드에 대한 접근이 전제되어야 한다.
ISO: 국제 표준화 기구</li>
</ul>
<pre><code>
$ ldd /bin/echo

ldd: 프로그램이 어떠한 라이브러리를 링크하고 있는 지 알 수 있는 명령어

</code></pre>
<h2 id="os가-제공하는-프로그램"><a class="header" href="#os가-제공하는-프로그램">OS가 제공하는 프로그램</a></h2>
<p>OS가 제공하는 프로그램은 OS가 제공하는 라이브러리와 마찬가지로 대부분의 프로그램이 필요하다
OS의 동작을 변경시키는 프로그램도 OS의 일부로써 제공된다.</p>
<ul>
<li>시스템 초기화: init</li>
<li>OS의 동작을 바꿈: sysctl, nice, sync</li>
<li>파일 관련: touch, mkdir</li>
<li>텍스트 데이터 가공: grep, sort, uniq</li>
<li>성능 측정: sar, iostat</li>
<li>컴파일러: gcc</li>
<li>스크립트 언어 실행 환경: perl, python, ruby</li>
<li>셀: bash</li>
<li>윈도우 시스템: X</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로세스-관리"><a class="header" href="#프로세스-관리">프로세스 관리</a></h1>
<h2 id="프로세스-생성의-목적"><a class="header" href="#프로세스-생성의-목적">프로세스 생성의 목적</a></h2>
<p>리눅스에서는 두 가지 목적으로 프로세스를 생성한다.</p>
<ol>
<li>같은 프로그램의 처리를 여러 개의 프로세스가 나눠서 처리한다. 예를 들어 웹 서버처럼 리퀘스트가 여러 개 들어왔을 때 동시에 처리해야 하는 경우</li>
<li>전혀 다른 프로그램을 생성합니다. 예를 들어 bash로부터 각종 프로그램을 새로 생성하는 경우</li>
</ol>
<h3 id="fork-함수"><a class="header" href="#fork-함수">fork() 함수</a></h3>
<p>목적1을 수행하는 함수이다.
fork 함수를 실행하면 실행한 프로세스와 함께 새로운 프로세스가 1개가 커널 메모리로부터 생성된다.
생성 전의 프로세스를 부모 프로세스(parent process), 새롭게 생성된 프로세스를 자식 프로세스(child process)라고 부릅니다.</p>
<ol>
<li>자식 프로세스용 메모리 영역을 작성하고 거기에 부모 프로세스의 메모리를 복사한다</li>
<li>fork 함수의 리턴 값이 각기 다른 것을 이용하며 부모 프로세스와 자식 프로세스가 서로 다른 코드를 실행하도록 분기한다.</li>
</ol>
<h3 id="execve-함수"><a class="header" href="#execve-함수">execve() 함수</a></h3>
<p>전혀 다른 프로그램을 생성할 때에는 execve() 함수를 사용한다.</p>
<ol>
<li>실행 파일을 읽은 다음 프로세스의 메모리 맵에 필요한 정보를 읽어들인다.</li>
<li>현재 프로세스의 메모리를 새로운 프로세스의 데이터로 덮어쓴다.</li>
<li>새로운 프로세스의 첫 번째 명령부터 실행한다.</li>
</ol>
<p>즉, 전혀 다른 프로그램을 생성하는 경우 프로세스의 수가 증가하는 것이 아니라 기존의 프로세스를 별도의 프로세스로 변경하는 방식으로 수행된다.
리눅스의 실행 파일은 실제로는 위에서 설명한 것 같은 단순한 것이 아니라 'ELF Executable and Linkable Format'라는 형식을 사용한다.
ELF 형식의 각종 정보는 'readelf' 명령어로 자세히 볼 수 있다.</p>
<pre><code>
$ readelf -h /bin/sleep

# readelf : ELF 형식의 각종 정보를 출력하는 명령어

</code></pre>
<h3 id="fork-and-exec-방식"><a class="header" href="#fork-and-exec-방식">fork and exec 방식</a></h3>
<p>bash 에서 echo를 실행하는 과정</p>
<ol>
<li>bash 메모리를 기준으로 fork()를 통해 자식 프로세스를 생성</li>
<li>자식 프로세스를 다른 프로그램으로 대체하기 위해 exec() 실행</li>
<li>echo의 메모리가 되어 echo 프로그램을 실행</li>
</ol>
<h3 id="_exit"><a class="header" href="#_exit">_exit()</a></h3>
<p>프로그램 종료는 '_exit()'함수를 사용한다.
( 내부에서는 exit_group() 시스템 콜을 호출한다 )
이 함수를 이용하면 할당된 메모리를 전부 회수한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로세스-스케줄러"><a class="header" href="#프로세스-스케줄러">프로세스 스케줄러</a></h1>
<p>리눅스 커널에는 '프로세스 스케줄러' 기능이 있는데 이 기능은 여러 개의 프로세스를 동시에 동작시킨다. 정확히는 동시에 동작시키는 것처럼 보이게 한다.</p>
<ul>
<li>
<p>하나의 CPU는 동시에 하나의 프로세스만 처리할 수 있다.</p>
</li>
<li>
<p>하나의 CPU에 여러 개의 프로세스를 실행해야 할 때는 각 프로세스를 적절한 시간으로 쪼개서(타임 슬라이스) 번갈아 처리한다.</p>
</li>
<li>
<p>프로세스를 종료시킬 때까지의 경과 시간은 프로세스 수에 비례하여 증가한다.</p>
</li>
<li>
<p>각 프로세스는 대략 같은 타임 슬라이스를 가진다.</p>
</li>
</ul>
<h2 id="라운드-로빈"><a class="header" href="#라운드-로빈">라운드 로빈</a></h2>
<ul>
<li>프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(타임 퀀텀)로 CPU를 할당하는 방식</li>
</ul>
<h2 id="컨텍스트-스위치"><a class="header" href="#컨텍스트-스위치">컨텍스트 스위치</a></h2>
<p>논리 CPU상에서 동작하는 프로세스가 바뀌는 것을 '컨텍스트 스위치'라고 부른다.</p>
<h2 id="프로세스의-상태"><a class="header" href="#프로세스의-상태">프로세스의 상태</a></h2>
<p>프로세스의 상태는 다음과 같다.</p>
<ul>
<li>실행 상태: 현재 논리 CPU를 사용하고 있다</li>
<li>실행 대기 상태: CPU 시간이 할당되기를 기다리고 있다.</li>
<li>슬립 상태: 이벤트가 발생하기를 기다리고 있으며 이벤트 발생까지는 CPU시간을 사용하지 않는다.</li>
<li>좀비 상태: 프로세스가 종료한 뒤 부모 프로세스가 종료 상태를 인식할 때까지 기다리고 있다.</li>
</ul>
<h2 id="idle-상태"><a class="header" href="#idle-상태">idle 상태</a></h2>
<ul>
<li>'아무것도 하지 않는' 특수한 프로세스가 동작한다.</li>
<li>시스템 전체가 CPU 시간을 거의 사용하지 않을 때</li>
</ul>
<h2 id="스루풋과-레이턴시"><a class="header" href="#스루풋과-레이턴시">스루풋과 레이턴시</a></h2>
<p>각종 성능지표인 스루풋과 레이턴시에 대해 정리한다.</p>
<ul>
<li>스루풋: 단위 시간당 처리된 일의 양이며 높을수록 좋다. 
( 완료한 프로세스의 수 / 경과 시간 )</li>
<li>레이턴시: 각각의 처리가 시작부터 종료까지의 경과된 시간으로 짧을수록 좋다. 
( 처리 종료 시간 - 처리 시작 시간 )</li>
</ul>
<h2 id="실제-시스템"><a class="header" href="#실제-시스템">실제 시스템</a></h2>
<p>실제 시스템에 돌아가는 논리 CPU는 다음과 같은 상태를 정신 없이 오고 간다.</p>
<ul>
<li>idle 상태: 논리 CPU가 쉬고 있기 때문에 스루풋이 떨어지는 경향이 있다.</li>
<li>프로세스가 동작 중: 실행 대기의 프로세스가 없기 때문에 이상적인 상태이다. 그러나 이러한 상태는 다음의 프로세스가 실행 가능한 상태가 되면, 2개의 프로세스의 레이턴시가 양쪽 다 길어진다.</li>
<li>프로세스가 대기 중: 실행 대기 프로세스가 있다. 스루풋은 높지만 레이턴시가 길어지는 경향이 있다.</li>
</ul>
<h2 id="논리-cpu가-여러-개일-때-스케줄링"><a class="header" href="#논리-cpu가-여러-개일-때-스케줄링">논리 CPU가 여러 개일 때 스케줄링</a></h2>
<p>논리 CPU가 여러 개일 때 스케줄링은 어떻게 될까? 이 때는 로드밸런서 혹은 글로벌 스케줄러라는 기능이 동작한다. 로드밸런서란 여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할을 한다.
프로세스를 할당받은 각 논리 CPU안에서 1개의 논리 CPU가 있을 떄와 마찬가지로 각 프로세스에 공평하게 CPU 시간을 분배한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="메모리-관리"><a class="header" href="#메모리-관리">메모리 관리</a></h1>
<p>리눅스는 커널의 메모리 관리 시스템으로 시스템에 탑재된 메모리를 관리한다.
메모리는 각 프로세스가 사용하는 것은 물론이고 커널 자체도 메모리를 사용한다.</p>
<h2 id="메모리-통계-정보"><a class="header" href="#메모리-통계-정보">메모리 통계 정보</a></h2>
<ul>
<li>total: 시스템에 탑재된 전체 메모리 용량</li>
<li>free: 표기상 이용하지 않는 메모리</li>
<li>buff/cache: 버퍼 캐시 또는 페이지 캐시가 이용하는 메모리. 시스템의 빈 메모리가 부족하면 커널이 해제한다.</li>
<li>available: 실질적으로 사용 가능한 메모리이다. free 필드 값의 메모리가 부족하면 해제되는 커널 내의 메모리 영역 사이즈를 더한 값으로, 해제될 수 있는 메모리에는 버퍼 캐시나 페이지 캐시의 대부분 혹은 다른 커널 내의 메모리 일부가 포함된다.
available 메모리 영역이 부족해지면 Out of Memory 현상이 일어난다.
OOM 현상으로 인해 OOM Killer라는 기능이 존재하는데
이 기능은 적절한 프로세스를 임의로 선택해 강제 종료하여 메모리 영역을 해제시킨다.</li>
</ul>
<h2 id="단순한-메모리-할당"><a class="header" href="#단순한-메모리-할당">단순한 메모리 할당</a></h2>
<p>먼저 가상 메모리가 없는 단순한 경우와 가상 메모리가 없어서 생기는 문제점에 대해 설명하겠다.</p>
<p>커널이 프로세스에 메모리를 할당하는 일은 크게 두 가지 타이밍이 벌어진다.</p>
<ol>
<li>프로세스를 생성할 때</li>
<li>프로세스를 생성한 뒤 추가로 동적 메모리를 할당할 때</li>
</ol>
<p>2의 동작의 경우 프로세스가 생성된 뒤 추가로 메모리가 더 필요하면 프로세스는 커널에 메모리 확보용 시스템 콜을 호출해서 메모리 할당을 요청한다.
커널은 메모리 할당 요청을 받으면 필요한 사이즈를 빈 메모리 영역으로부터 잘라내 그 영역의 시작 주소값을 반환한다.</p>
<p>이러한 메모리 할당 방법에는 문제점들이 있다.</p>
<ol>
<li>메모리 단편화 (memory fragmentation)</li>
<li>다른 용도의 메모리 접근 가능</li>
<li>여러 프로세스를 다루기 곤란</li>
</ol>
<h3 id="메모리-단편화"><a class="header" href="#메모리-단편화">메모리 단편화</a></h3>
<p>프로세스가 생성된 뒤 메모리의 획득, 해제를 반복하면 메모리 단편화 문제가 발생한다.
큰 메모리를 한번에 할당할 떄 문제가 됨</p>
<ul>
<li>프로그램은 메모리를 획득할 때마다 얻은 메모리가 몇 개의 영역에 나누어져 있는 지 확인해야 하므로 매우 불편하다</li>
<li>더 큰 용도의 메모리 할당에 문제가 생길 수 있다.</li>
</ul>
<h2 id="가상-메모리"><a class="header" href="#가상-메모리">가상 메모리</a></h2>
<p>가상 메모리는 간단하게 설명하면 시스템에 탑재된 메모리를 프로세스가 직접 접근하지 않고 가상 주소라는 주소를 사용하여 간접적으로 접근하도록 하는 방식이다.
프로세스에 보이는 메모리 주소를 '가상 주소', 시스템에 탑재된 메모리의 실제 주소를 '물리 주소'라고 부른다.
또한 주소에 따라서 접근 가능한 범위를 '가상 주소 공간'이라고 부른다.</p>
<h3 id="페이지-테이블"><a class="header" href="#페이지-테이블">페이지 테이블</a></h3>
<p>가상 주소에서 물리 주소로 변환하는 과정은 커널 내부에 보관되어 있는 '페이지 테이블'이라는 표를 사용한다. 가상 메모리는 전체 메모리를 페이지라는 단위로 나눠서 관리하고 있어서 변환은 페이지 단위로 이루어진다.</p>
<p>페이지 테이블에서 한 페이지에 대한 데이터를 '페이지 테이블 엔트리'라고 부르며 이 페이지 테이블 엔트리에는 가상 주소와 물리 주소의 대응 정보가 들어있다.
페이지 사이즈는 CPU 아키텍쳐에 따라 다르다. 흔히 사용하는 x86_64 아키텍쳐의 페이지 사이즈는 4킬로바이트이다.</p>
<p>물리 메모리에 매핑되어 있지 않은 가상 메모리에 접근을 하게되면 CPU에는 '페이지 폴트'라는 인터럽트가 발생한다. 페이지 폴트에 의해 현재 실행 중인 명령이 중단되고 커널 내의 '페이지 폴트 핸들러'라는 인터럽트 핸들러가 동작한다. 커널은 프로세스로부터 메모리 접근이 잘못되었다는 내용을 페이지 폴트 핸들러에 알려준다. 그 뒤 'SIGSEGV' 시그널을 프로세스에 통지한다. 이 시그널을 받은 프로세스는 강제로 종료된다.</p>
<h2 id="프로세스에-메모리를-할당할-때"><a class="header" href="#프로세스에-메모리를-할당할-때">프로세스에 메모리를 할당할 때</a></h2>
<p>커널이 프로세스를 생성할 때나 추가로 메모리를 요청받을 때, 가상 메모리를 통하여 어떻게 프로세스에 메모리를 할당하고 있는 지 살펴본다.</p>
<p>프로그램을 실행하는데 필요한 메모리 사이즈는 '코드 영역 사이즈 + 데이터 영역 사이즈'이다.
리눅스에서 실제 물리 메모리 할당은 '디맨드 페이징'이라는 방식을 사용한다.</p>
<h2 id="가상-메모리-응용"><a class="header" href="#가상-메모리-응용">가상 메모리 응용</a></h2>
<ul>
<li>파일 맵</li>
<li>디맨드 페이징</li>
<li>Copy on Write 방식의 고속 프로세스 생성</li>
<li>스왑(Swap)</li>
<li>계층형 페이지 테이블</li>
<li>Hupe page</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="메모리-계층"><a class="header" href="#메모리-계층">메모리 계층</a></h1>
<p>메모리 장치의 계층 구조를 도식화한 그림</p>
<p>레지스터<br />
캐시 메모리
메모리
저장 장치</p>
<p>아래부터 위</p>
<ul>
<li>사이즈 큼 -&gt; 작음</li>
<li>가격 쌈 -&gt; 비쌈</li>
<li>접근속도 느림 -&gt; 빠름</li>
</ul>
<h2 id="캐시-메모리"><a class="header" href="#캐시-메모리">캐시 메모리</a></h2>
<p>컴퓨터의 동작흐름은 아래와 같다</p>
<ol>
<li>명령어를 바탕으로 메모리에서 레지스터로 데이터를 읽는다.</li>
<li>레지스터에 있는 데이터를 바탕으로 계산한다.</li>
<li>계산 결과를 메모리에 쓴다.</li>
</ol>
<p>캐시 메모리는 레지스터 안에서 계산하는 것과 메모리에 접근하는 것, 양쪽의 처리 시간의 차이를 메우는 역할을 한다.</p>
<p>캐시 메모리로부터 레지스터에 접근할 때의 레이턴시는 메모리에 접근할 때와 비교해보면 수배에서 수십배 빠른 점을 이용해 속도를 고속화한다. 캐시 메모리는 일반적으로 CPU에 내장되어 있지만 CPU의 바깥에 있는 캐시 메모리도 있다.</p>
<p>메모리에서 레지스터로 데이터를 읽어올 때는, 일단 캐시 메모리에 읽어온 뒤 같은 내용을 다시 레지스터로 읽어들인다. 이때 읽어오는 크기는 CPU에서 정한 '캐시 라인 사이즈'만큼이다.</p>
<p>메모리로부터 읽어 들인 데이터가 변경되었음을 플래그로 표시하는 데 이 표시된 라인을 '더티'라고 한다.
이 더티 플래그가 붙어 있는 데이터는 나중에 백그라운드 처리로 메모리에 다시 기록된다. 다시 기록되면 더티 플래그는 사라진다.</p>
<h3 id="캐시-메모리가-가득-찬-경우"><a class="header" href="#캐시-메모리가-가득-찬-경우">캐시 메모리가 가득 찬 경우</a></h3>
<p>캐시 메모리가 가득 찬 경우, 캐시 메모리에 존재하지 않는 데이터를 추가로 읽으면 기존의 캐시 메모리 중 1개를 파기한다. 파기되어 비워진 라인에 새 데이터를 넣는다.</p>
<p>캐시 메모리가 가득 차고 모든 캐시 라인이 더티라면 메모리 접근을 할 때마다 캐시 라인 안의 데이터가 자주 바뀌는 스래싱이 발생하여 성능이 크게 감속할 수 있다.</p>
<h3 id="메모리-참조의-국소성"><a class="header" href="#메모리-참조의-국소성">메모리 참조의 국소성</a></h3>
<p>(국소성: 충분히 멀리 떨어진 두 물체는 곧바로 상용하지 않는다는 원리)</p>
<p>프로세스의 데이터가 전부 캐시에 있는 동안에는 데이터에 접근하는 속도는 메모리에 접근하는 속도가 아니라 이보다 빠른 캐시에 접근하는 속도이다. 프로그램은 대부분 메모리 참조의 국소성이라고 하는 다음과 같은 특성이 있다.</p>
<ul>
<li>시간 국소성: 특정 시점에서 접근하는 데이터는 가까운 미래에 다시 접근할 가능성이 크다. 전형적인 예로는 루프 처리중인 코드 영역을 들 수 있다.</li>
<li>공간 국소성: 특정 시점에 어떤 데이터에 접근하면 그 데이터와 가까운 주소에 있는 데이터를 접근할 확률이 높다. 전형적인 예로는 배열의 전체 검색 등을 들 수 있다.</li>
</ul>
<p>이러한 이유로 프로세스는 짧은 시간을 놓고 생각해보면, 자신이 획득한 메모리의 총량보다 훨씬 좁은 범위의 메모리에 접근하는 성향이 있다. 이 좁은 범위를 캐시 메모리의 사이즈가 커버할 수 있으면 성능이 좋은 것이다.</p>
<h3 id="정리"><a class="header" href="#정리">정리</a></h3>
<p>프로그램의 워크로드를 캐시 메모리 사이즈에 들어가게 하는 것으로 성능을 크게 향상시킬 수 있다.
속도를 중요시하는 프로그램이라면 캐시 메모리의 효과를 최대한으로 끌어내기 위해 데이터의 배열이나 알고리즘 혹은 설정을 연구해서 단위 시간 당 메모리 접근 범위를 작게 하는 것이 중요하다.</p>
<p>한편, 시스템 설정을 변경했을 때 프로그램의 성능이 크게 나빠진 경우에는 프로그램의 데이터가 캐시 메모리에 전부 들어가지 않았을 가능성이 있다.</p>
<h2 id="translation-lookaside-buffer"><a class="header" href="#translation-lookaside-buffer">Translation Lookaside Buffer</a></h2>
<p>프로세스는 다음과 같은 순서에 따라 가상 주소의 데이터에 접근한다.</p>
<ol>
<li>물리 메모리상에 존재하는 페이지 테이블을 참고하여 가상 주소를 물리 주소로 변환한다.</li>
<li>1에서 구한 물리 메모리에 접근한다.</li>
</ol>
<p>캐시 메모리를 사용하여 고속화하는 것은 2번뿐이다. 왜냐하면 1은 물리 메모리상에 있는 페이지 테이블에 접근해야 하므로 캐시가 동작할 수 없다.</p>
<p>이 문제를 해결하기 위해 CPU에는 가상 주소에서 물리 주소로의 변환표를 보관하는 한편, 캐시 메모리와 똑같이 고속으로 접근 가능한 TLB 라는 영역이 있다. 이것을 가지고 1을 고속화 한다.</p>
<h3 id="페이지-캐시"><a class="header" href="#페이지-캐시">페이지 캐시</a></h3>
<p>CPU로부터 메모리에 접근하는 속도에 비해 저장 장치에 접근하는 속도는 엄청나게 느리다.
이 속도 차이를 줄이기 위해 커널에는 '페이지 캐시'기능이 있다.</p>
<p>페이지 캐시는 캐시 메모리와 매우 비슷하다
캐시 메모리가 메모리의 데이터를 캐싱하느 ㄴ것과 비슷하게 페이지 캐시는 저장 장치 내의 파일 데이터를 메모리에 캐싱한 것이다.</p>
<p>캐시 메모리는 캐시 라인 단위로 데이터를 다루지만 페이지 캐시는 페이지 단위로 데이터를 다룬다.
페이지 캐시의 동작 흐름을 구체적으로 살펴본다.</p>
<p>프로세스가 파일의 데이터를 읽어 들이면 커널은 프로세스의 메모리에 파일의 데이터를 직접 복사하는 것이 아니라 커널의 메모리 내에 있는 페이지 캐시라는 영역에 복사한 뒤 이 데이터를 프로세스 메모리에 복사한다.</p>
<p>커널은 자신의 메모리 안에 페이지 캐시에 캐싱한 파일과 그 범위 등의 정보를 보관하는 관리 영역을 가지고 있다.</p>
<p>그리고 페이지 캐시에 존재하는 데이터를 다시 읽으면 커널은 페이지 캐시의 데이터를 돌려준다.</p>
<p>이 방법은 저장 장치에 접근하는 경우에 비해 훨씬 더 빠르게 처리된다.
또한 페이지 캐시는 전체 프로세스 공유의 자원이므로 읽어 들인 프로세스는 최초에 파일 데이터에 접근한 프로세스와 다른 프로세스여도 문제가 없다.</p>
<h3 id="페이지-캐시-쓰기"><a class="header" href="#페이지-캐시-쓰기">페이지 캐시 쓰기</a></h3>
<p>프로세스가 데이터를 파일에 쓰면 커널은 페이지 캐시에 데이터를 쓴다.
이때 관리 영역 내에 해당하는 데이터에 대응되는 엔트리에 '데이터의 내용은 저장 장치의 내용보다 새로운 것'이라는 플래그를 붙여둔다. 이 플래그가 붙은 페이지를 더티 페이지라고 부른다.</p>
<p>이것도 읽기와 마찬가지로 저장 장치에 접근하는 것에 비해 훨씬 더 빠르게 처리된다.
더티 페이지의 내용은 나중에 커널의 백그라운드로 처리하며 스토리지 내의 파일에 반영한다.
이때 더티 페이지의 플래그를 지운다.</p>
<p>각 프로세스가 접근하는 파일의 데이터가 전부 페이지 캐시에 있으면 시스템 파일의 접근 속도는 저장 장치의 접근 속도가 아닌 메모리 접근 속도에 근접하므로 시스템 전체가 빠르게 동작한다.</p>
<p>또한 페이지 캐시 사이즈는 시스템의 메모리가 비어 있는 한, 시스템 내의 각 프로세스가 페이지 캐시에 없는 파일을 읽을 때마다 점점 증가한다.</p>
<p>시스템 메모리가 부족해지면 커널은 페이지 캐시를 해제하여 빈 영역을 만든다. 이 경우 더티가 아닌 페이지를 파기한다. 그래도 시스템 메모리가 부족하면 더티 페이지를 라이트 백 한 뒤에 파기한다.
더티 페이지는 저장 장치 접근이 발생하므로 시스템의 성능이 느려지는 문제점이 있다. 파일에 쓰기가 많아서 더티 페이지가 많아지는 시스템은 부하가 많아질 수 밖에 없다. 메모리 부족이 더티 페이지의 라이트 백을 자주 발생시켜 시스템이 느려지는 일은 굉장히 자주 있다.</p>
<h2 id="버퍼-캐시"><a class="header" href="#버퍼-캐시">버퍼 캐시</a></h2>
<p>페이지 캐시와 비슷한 구조로 버퍼 캐시라는 것이 있다.
이것은 파일시스템을 사용하지 않고 나중에 설명할 디바이스 파일을 이용하여 저장 장치에 직접 접근하는 등의 목적으로 사용한다.</p>
<p>페이지 캐시와 버퍼 캐시를 합쳐서 저장 장치 안의 데이터를 메모리에 넣어두는 방식이라 한다.</p>
<h2 id="정리-1"><a class="header" href="#정리-1">정리</a></h2>
<p>파일의 데이터가 페이지 캐시에 있다면 없는 경우와 비교해서 파일 접근이 매우 빨라진다.
그렇게 하기 위해서는 시스템이 접근하는 파일의 사이즈나 물리 메모리의 양을 비교하여 맞추는 것이 중요하다.</p>
<p>설정 변경이나 시간이 지나면서 시스템의 성능이 갑자기 느려졌다면 파일의 데이터가 페이지 캐시에 제대로 들어가지 못했을 수 있다. 여러가지 sysctl 파라미터를 잘 튜닝한다면 페이지 캐시의 라이트 백이 자주 발생하여서 생기는 I/O 부하를 막을 수 있다. 또한 sar - B나 sar -d -p등을 이용하여 페이지 캐시에 관한 통계 정보를 얻을 수 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="파일-시스템"><a class="header" href="#파일-시스템">파일 시스템</a></h1>
<p>리눅스에서는 저장 장치 안의 데이터에 접근할 때 일반적으로 직접 저장 장치에 접근하지 안혹 편의를 위해 파일 시스템을 통해 접근한다.</p>
<p>저장 장치의 기능은 단순하게 말하면 '저장 장치 안에 지정뙨 주소에 대해 특정 사이즈의 데이터를 읽거나 씀'이다. </p>
<p>저장 장치안에 어디에 어느 정도의 데이터가 있는 지 어디가 빈 영역인지를 관리하는 방법이 파일 시스템이다.</p>
<h2 id="리눅스의-파일시스템"><a class="header" href="#리눅스의-파일시스템">리눅스의 파일시스템</a></h2>
<p>파일을 카테고리별로 정리할 수 있도록 리눅스의 파일시스템에는 디렉터리 라고 부르는 파일을 보관하는 특수한 파일이 존재한다.
디렉터리 안에는 일반적인 파일 또는 다른 디렉터리를 보관하는 것이 가능하며 각각 다른 디렉터리 안에 존재한다면 여러파일이 같은 이름을 가져도 된다. 이러한 방식을 위해 리눅스의 파일시스템은 트리구조로 되어있다.</p>
<p>리눅스가 다루는 파일 시스템은 'ext4', 'XFS', 'Btrfs'등 1개 이상이다.</p>
<h2 id="데이터와-메타데이터"><a class="header" href="#데이터와-메타데이터">데이터와 메타데이터</a></h2>
<p>데이터: 사용자가 작성한 문서나 사진, 동영상, 프로그램 등의 내용
메타데이터: 파일의 이름이나 저장 장치 내에 위치 사이즈 등의 보조 정보</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="저장-장치"><a class="header" href="#저장-장치">저장 장치</a></h1>
<h2 id="hdd의-데이터-읽기-쓰기의-동작-방식"><a class="header" href="#hdd의-데이터-읽기-쓰기의-동작-방식">HDD의 데이터 읽기 쓰기의 동작 방식</a></h2>
<p>HDD는 자기 정보로 변환하여 그것을 플래터라고 불리는 자기 장치에 기록하는 저장 장치이다.
데이터는 바이트 단위가 아닌 섹터라고 불리는 단위로 읽고 쓴다.</p>
<p>플래터의 각 섹터 데이터는 자기 헤드라는 부품에 의해 읽고 쓴다.
자기 헤드는 스윙 암이라는 부품에 달려있으며 스윙 암이 움직임으로써 자기 헤드를 플래터의 동심원 반경 방향으로 이동시킨다.
여기에 플래터를 회전시킴으로써 자기 헤드를 읽고 싶은 대상 섹터의 바로 위에 오도록 한다</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
